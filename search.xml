<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 function什么是函数​ 函数是可以重复执行的语句块,可以重复的调用 ​ 函数是面向过程编程的最小单位 作用: ​ \1. 用于封装语句块,提高代码的重用性 ​ \2. 定义用户级别的函数 def 语句 语法: ​ def 函数名(形参列表): ​ 语句块 说明: ​ \1. 函数的名字就是语句块的名称 ​ \2. 函数名的命名规则写变量名的规则相同(必须是标识符) ​ \3. 函数名是一个变量(不要轻易对其赋值) ​ \4. 函数有自己的名字空间,在函数外部不可能访问函数内部的变量,在函数内部可以访问函数外部的变量 ​ 要让函数处理处部的数据最好用参数给函数传入一些数据 ​ \5. 函数如果不需要传入参数,参数列表可以为空 ​ \6. 语句部分不能为空.如果为空需要填充pass语句 12345678910# 此示例示意函数的定义和调用def say_hello(): print(&quot;hello world!&quot;) print(&quot;hello Tarena!&quot;) print(&quot;hello everyone!&quot;)say_hello() # 调用一次say_hellosay_hello() # 调用第二次say_hello() # 第三次 12345678910# 此示例示意写一个函数,此函数的功能是给它两个数据,让它把最大值的数据打印出来def mymax(a, b): m = a if b &gt; m: m = b print(&quot;最大值的数据是:&quot;, m)mymax(100, 200)mymax(&quot;ABC&quot;, &quot;123&quot;) 函数调用 函数名(实际调用传递参数) 说明: ​ 函数调用是一个表达式.如果函数内没有return语句.默认返回None对象 练习: 写一个函数myadd,此函数中的参数列表里有两个参数x, y,此函数的功能是打印 x + y的和: 如: ​ def myadd(…): ​ … # …是需要填充的部分 ​ ​ myadd(100, 200) # 打印300 ​ myadd(“ABC”, “123”) # 打印 ABC123 return 语句 语法: ​ return [表达式] ​ 注: [] 代表其中的内容可省略 作用: ​ 用于函数中,结束当前函数的执行,返回到调用函数的地方,同时返回一个对象的引用关系 说明: ​ \1. return 语句后跟的表达式可以省略,省略后相当于 return None ​ \2. 如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句) 1234567891011121314151617181920# 此示例示意return语句的作用和用法def say_hello2(): print(&quot;hello aaa&quot;) print(&quot;hello bbb&quot;) # return # 等同于return None # return 1 + 2 return [1, 2, 3, 3 + 1] print(&quot;hello ccc&quot;)r = say_hello2() print(&quot;r=&quot;, r) print(&quot;程序结束&quot;)# hello aaa# hello bbb# r= [1, 2, 3, 4]# 程序结束 12345678910111213141516# 此示例示意return语句的作用和用法def say_hello2(): print(&quot;hello aaa&quot;) print(&quot;hello bbb&quot;) print(&quot;hello ccc&quot;) # 此处相当于有条语句 return Noner = say_hello2() # 调用print(&quot;r=&quot;, r) # None# hello aaa# hello bbb# hello ccc# r= None 练习: \1. 写一个函数 myadd2, 实现给出两个数,返回这两个数的和 ​ 如: ​ def myadd(x, y): ​ ….. ​ a = int(input(“请输入第一个数: “)) ​ b = int(input(“请输入第二个数: “)) ​ print(“您输入的这两个数的和是”, myadd2(a, b)) 12345678910111213def myadd2(x, y): z = x + y return z # return x + ya = int(input(&quot;请输入第一个数: &quot;))b = int(input(&quot;请输入第二个数: &quot;))print(&quot;您输入的这两个数的和是&quot;, myadd2(a,b))#请输入第一个数: 1#请输入第二个数: 2#您输入的这两个数的和是 3 \2. 写一个函数mymax3,返回三个数中最大的一个值 ​ def mymax3(a, b, c): ​ …. # 此处自己实现 ​ ​ print(mymax3(100, 300, 200)) # 300 ​ print(mymax3(“ABC”, “123”, “abc”)) # abc 123456789101112131415161718192021222324# 方法1# def mymax3(a, b, c):# zuida = a# if b &gt; zuida:# zuida = b# if c &gt; zuida:# zuida = c# return zuida# 方法2# def mymax3(a, b, c):# z = a if a &gt; b else b# z = z if z &gt; c else c# return zdef mymax3(a, b, c): return max(a, b, c) # z = max(a, b) # z = max(z, c) # return zprint(mymax3(100, 300, 200)) # 300print(mymax3(&quot;ABC&quot;, &quot;123&quot;, &quot;abc&quot;)) # abc \3. 写一个函数 input_numbers,如下: ​ def input_numbers(): ​ …. # 此处自己实现 ​ 此函数用来获取用户循环输入的正整数,当用户输入负数时结束输入 ​ 将用户输入的数字以列表的形式返回,再用内建函数max,min,sum求出用户输入数的最大值,最小值及和 ​ L = input_numbers() ​ print(L) # 打印列表 ​ print(“用户输入的最大数是:”, max(L)) ​ print(“用户输入的最小数是:”, min(L)) ​ print(“用户输入的数的和是:”, sum(L)) 123456789101112131415def input_numbers(): lst = [] while True: n = int(input(&quot;请输入正整数(负数结束):&quot;)) if n &lt; 0: return lst # break # return lst lst.append(n) # return lstL = input_numbers()print(L) # 打印列表print(&quot;用户输入的最大数是:&quot;, max(L))print(&quot;用户输入的最小数是:&quot;, min(L))print(&quot;用户输入的数的和是:&quot;, sum(L)) 练习: \1. 写一个函数get_chinese_char_count(s) 函数,此函数实现的功能是给定一个字符串,返回这个字符串中中文字符的个数 ​ def get_chinese_char_count(s): ​ …. # 此处自己实现 ​ ​ s = input(“请输入中英文混合的字符串: “) ​ print(“您输入的中文字符的个数是:”, ​ get_chinese_char_count(s)) 12345678910111213def get_chinese_char_count(s): count = 0 # 记录中文字符的个数 # 此处用来记中文数 for ch in s: if ord(ch) &gt; 127: count += 1 return counts = input(&quot;请输入中英文混合的字符串: &quot;)print(&quot;您输入的中文字符的个数是:&quot;, get_chinese_char_count(s)) \2. 定义两个函数: ​ sum3(a, b, c) 用于返回三个数的和 ​ pow3(x) 用于返回x的三次方(立方) ​ 用以上函数计算: ​ 1) 计算 1的立方+ 2的立方 + 3的立方 ​ 2) 计算 1 + 2 + 3的和的立方 ​ 即:13 + 23+33 和 (1+2+3)3 1234567891011121314def sum3(a, b, c): return a + b + cdef pow3(x): return x ** 3# 1) 计算 1的立方+ 2的立方 + 3的立方s = sum3(pow3(1), pow3(2), pow3(3))print(s)# 2) 计算 1 + 2 + 3的和的立方s = pow3(sum3(1, 2, 3))print(s)# 即:1**3 + 2**3+3**3 和 (1+2+3)**3 函数的参数: 1.函数实际调用参数传递(把数据给函数) 2.函数的形式参数(从调用者拿来(接收)数据) 函数的实际调用参数传递 传递方式: ​ 1.位置传参 ​ 1.1 序列传参 ​ 2.关键字传参 ​ 2.2 字典关键字传参 位置传参: 实际参数(实参)的对应关系与形式参数(形参)的对应关系是按位置来依次对应的 示意: ​ def mymin(a, b, c): ​ pass ​ # ^ ^ ^ ​ mymin( 1, 2, 3) 说明: 实参个数必须与形参个数相同 12345678# 此示例示意位置传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)myfun1(1, 2, 3) # 1--&gt;a 2--&gt; b...myfun1(4, 5, 6) # 4--&gt;a 5--&gt; b... 序列传参: 序列: 字符串,列表,元组 序列传参是指在函数调用过程中,用*(星号)将序列拆解后按位置进行传递的传参方式 12345678910111213# 此示例示意序列传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)s1 = [11, 22, 33]# myfun1(s1[0], s1[1], s1[2])myfun1(*s1) # 相当于 myfun1(11, 22, 33)s2 = (44, 55, 66)s3 = &quot;ABC&quot;myfun1(*s2)myfun1(*s3) 说明: ​ 序列传参时,序列拆解的位置将与形参一一对应 ​ 序列的位置信息对应相应的参数位置 关键字传参 关键字传参是指传参时,按着形参的名称给形参赋值 实参和形参按名称进行匹配 示例见: 12345678910# 此示例示意关键字传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)myfun1(c=300, b=200, a=100)myfun1(b=20, c=30, a=10)# myfun1(b=2, c=3, b=1) # 报错 说明: ​ 实参和形参可以不按位置进行匹配. 字典关键字传参 是指实参为字典 将字典用 **(双星号) 拆解后进行关键字传参的传参方式 12345678910111213141516# 此示例示意字典关键字传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)d1 = &#123;&apos;c&apos;: 33, &apos;b&apos;:22, &apos;a&apos;:11&#125;# myfun1(d1[&apos;a&apos;], d1[&apos;b&apos;], d1[&apos;c&apos;])# myfun1(a=d1[&apos;a&apos;], b=d1[&apos;b&apos;], c=d1[&apos;c&apos;])myfun1(**d1) # 等同于myfun1(a=11,b=22,c=33)d2 = &#123;&apos;c&apos;: 33, &apos;b&apos;:22, &apos;a&apos;:11, &apos;d&apos;:44&#125;# myfun1(**d2) # 报错# a的值是: 11# b的值是: 22# c的值是: 33 说明: ​ 字典的键名和形参名必须一致 ​ 字典的键名必须是字符串,且必须为标识符的命名规则 ​ 字典的键名要在形参中存在 函数综合传参 函数的传参方式,在能确定形参能唯一匹配到相应实参的情况下可以任意组合 函数的位置传参要先于关键字传参 \1. 函数的位置传参和序列传参可以混合使用,且可以顺序颠倒 ​ myfun1(100, *[200, 300]) ​ myfun1(*[100, 200], 300) ​ myfun1([100], 200, [300]) \2. 函数位置传参和关键字传参可以混合使用 ​ myfun1(100, c=300, b=200) ​ myfun1(100, **{“c”:300}, b=200) ——-以下讲的函数的定义及函数的形参—- 函数的缺省参数 语法: ​ def 函数名(形参名1=默认实参1, 形参名2=默认实参2, …): ​ 语句块 123456789101112# 此示例示意函数的缺省参数def info(name, age=1, address=&quot;不详&quot;): print(name, &quot;今年&quot;, age, &apos;岁&apos;, &apos;家庭住址:&apos;, address)info(&quot;魏明择&quot;, 35, &apos;北京市朝阳区&apos;)info(&quot;Tarena&quot;, 16)info(&quot;张飞&quot;)#魏明择 今年 35 岁 家庭住址: 北京市朝阳区# Tarena 今年 16 岁 家庭住址: 不详#张飞 今年 1 岁 家庭住址: 不详 说明: ​ \1. 缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数 ​ \2. 缺省参数可以有0个,1个或多个,甚至全部都是缺省参数 示例: ​ def fn(a, b=10, c): # 错的 ​ pass ​ def fn(a=0, b=10, c=20): # 对的 ​ pass ​ 练习: 写一个函数 myadd,此函数可以计算两个数,三个数及四个数的和. ​ 如: ​ def myadd(…): ​ … ​ print(myadd(10, 20)) # 30 ​ print(myadd(100, 200, 300)) # 600 ​ print(myadd(1, 2, 3, 4)) # 10 123456def myadd(a, b, c=0, d=0): return a + b + c + dprint(myadd(10, 20)) # 30print(myadd(100, 200, 300)) # 600print(myadd(1, 2, 3, 4)) # 10 函数形参的定义方式: 位置形参 星号元组形参 命名关键字形参 双星号字典形参 位置形参: 语法: ​ def 函数名(形参名1, 形参名2, …): ​ 语句块 星号元组形参 语法: ​ def 函数名(* 元组形参名): ​ 语句块 作用: ​ 收集多余的位置传参 说明: ​ 元组形参名一般命名为 ‘args’ 123456789101112# 此示例示意星号元组形参的定义及使用def func(*args): print(&quot;用户传入的参数个数是:&quot;,len(args)) print(&apos;args=&apos;, args)# func() # 无参调用# func(1, 2, 3)func(1, 2, 3, &quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;)#用户传入的参数个数是: 6# args= (1, 2, 3, &apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;) 练习: 写一个函数,mysum 可以传入任意个数字的实参,此函数调用将返回实参的和 123456789def mysum(*args): # s = 0 # for x in args: # s += x # return s return sum(args)print(mysum()) # 0print(mysum(1, 2, 3)) # 6 练习: 写一个函数min_max(…) 函数, 此函数至少要传一个参数,并返回全部这些数数的最小值,最大值(形成元组,最小在前,最大值在后) 调用此函数,得到最小值和最大值并打印出来 123456789101112131415161718192021222324252627282930313233343536373839# 方法1# def min_max(a, *args):# zuixiao = a# for x in args:# if x &lt; zuixiao:# zuixiao = x# # 求最大# zuida = a# for x in args:# if x &gt; zuida:# zuida = x# return (zuixiao, zuida)# 方法2 # def min_max(a, *args):# zuixiao = min(args) # 先从第二个起的参数选出最小值# if a &lt; zuixiao:# zuixiao = a # zuida = max(args)# if a &gt; zuida:# zuida = a# return (zuixiao, zuida)# 方法3def min_max(a, *args): zuixiao = min(a, *args) zuida = max(a, *args) return (zuixiao, zuida)print(min_max(10, 20, 30)) # (10,30)x, y = min_max(8, 6, 4, 3, 9, 2, 1)print(&quot;最小值是:&quot;, x) # 1print(&quot;最大值是:&quot;, y) # 9# print(min_max()) # 没有实参报错 命名关键字形参: 语法: ​ def 函数名(*, 命名关键字形参1,命名关键字形参2, …): ​ 语句块 ​ # 或 ​ def 函数名(*args, 命名关键字形参1,命名关键字形参2, …): ​ 语句块 作用: ​ 强制所有的命名关键字形参都必须用关键字传参或字典关键字传参 123456789# 此示例示意命名关键字形参的定义的方式和调用方法def f1(*, c, d): #*之后的形参为命名关键字形参 print(&quot;c=&quot;, c) print(&quot;d=&quot;, d)# f1(3, 4) # 报错f1(d=4, c=3) # 关键字正确d1 = &#123;&apos;c&apos;:30, &apos;d&apos;: 40&#125;f1(**d1) 123456789# 此示例示意命名关键字形参的定义的方式和调用方法def f2(a, b, *args, c, d): print(a, b) print(args) print(c, d)# f2(1, 2, 3, 4, d=200, c=100)f2(11,22, 33, **&#123;&apos;c&apos;:11, &apos;d&apos;:22&#125;) 双星号字典形参 语法: ​ def 函数名(**字典形参名): ​ 语句块 作用: ​ 收集多余的关键字传参 说明: ​ 字典形参名一般命名为”kwargs” 1234567891011121314151617# 此示例示意双星号字典形参的定义和调用def fun(**kwargs): print(&quot;关键字传参个数是&quot;, len(kwargs)) print(&apos;kwargs=&apos;, kwargs)fun(a=1, b=&quot;BBBB&quot;, c=[2,3,4]) # 关键字传参fun()fun(a=1, b=2, c=3, d=4)#关键字传参个数是 3# kwargs= &#123;&apos;a&apos;: 1, &apos;b&apos;: &apos;BBBB&apos;, &apos;c&apos;: [2, 3, 4]&#125;#关键字传参个数是 0# kwargs= &#123;&#125;#关键字传参个数是 4# kwargs= &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125; 函数的参数说明: 位置形参,星号元组形参,命名关键字形参,双星号字典形参,缺省参数可以混合使用 函数参数自左至右的顺序为: 位置形参 星号元组形参 命名关键字形参 双星号字典形参 示例: def fx(a, b, *args, c, d, **kwargs): ​ pass fx(1,2,3,4,5, c=’C’, d=’D’, e=’E’) # 可以接收任意的位置传参和关键字传参的函数: def fn(*args, **kwargs): ​ print(‘args=’, args) ​ print(‘kwargs=’, kwargs) fn(1, 2, “ABCD”, [11,22], 3, c=100,**{‘a’:200}) 思考题: 查看 ​ >&gt;&gt; help(print) 猜想print()函数是形参列表是如何定义的? ​ def myprint(*args, sep=’ ‘, end=’\n’): 查看&gt;&gt;&gt; range()函数猜想它的形参列表是如何定义的 练习: 写一个myrange函数,参数可以传入1~3个,实际含义与range函数相同 此函数返回符合range(…) 函数的列表 如: ​ L = myrange(4) ​ print(L) # [0, 1, 2, 3] ​ L = myrange(4, 6) ​ print(L) # [4, 5] ​ L = myrange(1, 10, 3) ​ print(L) # [1, 4, 7] (注: 可以调用range) 12345678910111213141516171819202122def myrange(a, b=None, c=None): if b is None: start = 0 stop = a # 第一个数 else: start = a stop = b if c is None: step = 1 else: step = c # print(&quot;开始值:&quot;, start, # &quot;结束值:&quot;, stop, # &apos;步长&apos;, step) return list(range(start, stop, step))L = myrange(4)print(L) # [0, 1, 2, 3]L = myrange(4, 6)print(L) # [4, 5]L = myrange(1, 10, 3)print(L) # [1, 4, 7] 全局变量和局部变量 局部变量: 定义在函数内部的变量称为局部变量(函数的形参也是局部变量) 局部变量只能在函数内部使用 局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁 全局变量: 定义在函数外部,模块文件内部的变量称为全局变量 全局变量,所有的函数都可以直接访问(但不能直接将其赋值) 1234567891011121314# 此示例示意全局变量和局部变量a = 100 # 全局变量b = 200 # 全局变量def fx(c): # c是局部变量 d = 400 # 局部变量 a = 10000 print(a, b, c, d) # 优先访问局部变量fx(300)print(&apos;a =&apos;, a) # 100print(&apos;b =&apos;, b)# print(&apos;c =&apos;, c) # 出错# print(&apos;d =&apos;, d) # 出错 说明: \1. 在函数内部的赋值语句会创建局部变量,不会对全局变量造成影响 \2. 局部变量只能在其被声明的函数内部访问,而全局变量可以在整个模块范围内访问 globals() 和 locals() 函数 globals() 返回当前全局作用域内变量的字典 locals() 返回当前局部作用域内变量的字典 123456789101112131415a = 1b = 2c = 3def fn(c, d): e = 300 # 此时有几个局部变量 print(&quot;locals() 返回:&quot;, locals()) #此时有几个全局变量 print(&quot;globals() 返回:&quot;, globals()) print(c) # 访问局部变量100 print(globals()[&apos;c&apos;]) # 访问全局变量c 3fn(100, 200) 练习: 素数/质数 ​ 2, 3, 5, 7, 11, 13 \1. 写一个函数isprime(x) 判断x是否是素数.如果是素数返回True,否则返回False 1234567891011121314def isprime(x): # 如果x小于2不是素数 if x &lt; 2: return False # 如果x大于等于2,则用x对2...x-1的数求余. for i in range(2, x): # 如果余数为0则不是素数 if x % i == 0: return False # 否则就为素数 return Trueprint(isprime(4)) # Falseprint(isprime(5)) # True \2. 写一个函数prime_m2n(m, n) 返回从m开始,到n结束的范围内的素数(不包含n),返回这些素数的列表,并打印 ​ 如: ​ L = prime_m2n(5, 10) ​ print(L) # [5, 7] 12345678910def prime_m2n(m, n): L = [] for x in range(m, n): # 判断如果x是素数,则加到列表L中 if isprime(x): L.append(x) return LL = prime_m2n(5, 10)print(L) # [5, 7] \3. 写一个函数primes(n) 返回指定范围n以内的素数(不包含n)的全部素数的列表,并打印这些素数 ​ L = primes(10) ​ print(L) # [2, 3, 5, 7] ​ 1) 打印100以内的全部素数 ​ 2) 打印200以内的全部素数的和 123456789def primes(n): return prime_m2n(0, n)L = primes(10)print(L) # [2, 3, 5, 7]# 1) 打印100以内的全部素数print(primes(100))# 2) 打印200以内的全部素数的和print(sum(primes(200))) 函数变量 函数名是变量,他在创建时绑定一个函数 1234567891011# 此示例示意函数名绑定函数,函数名是变量 def fn(): print(&quot;hello world&quot;)f1 = fnprint(f1) # &lt;function fn at 0x7f0bb2eb0f28&gt;fn() # hello worldf1() # hello worldf2 = fn() #print(f2) # None 12345678def f1(): print(&quot;hello f1&quot;)def f2(): print(&quot;hello f2&quot;)f1, f2 = f2, f1f1() # hello f2 一个函数可以作为另一个函数的实参传递 1234567891011121314151617def f1(): print(&quot;hello f1&quot;)def f2(): print(&quot;hello f2&quot;)def fx(fn): print(fn) # &lt;function f1 at 0x????&gt; fn() # 请问调用谁?fx(f1)fx(f2)#&lt;function f1 at 0x0000000002071E18&gt;#hello f1#&lt;function f2 at 0x0000000002856598&gt;#hello f2 观查下面函数的执行结果是什么? def goodbye(L): ​ for x in L: ​ print(“再见:”, x) def hello(L): ​ for x in L: ​ print(“您好:”, x) def fx(fn, L): ​ fn(L) fx(goodbye, [“Tom”, “Jerry”, “Spike”]) 看懂如下代码: def myinput(fn): ​ L = [1, 3, 5, 7, 9] ​ r = fn(L) ​ return r print(myinput(max)) # 9 print(myinput(min)) # 1 print(myinput(sum)) # 25 结果： 再见: Tom 再见: Jerry 再见: Spike 函数可以作为另一个函数的返回值 1234567891011121314# 函数可以作为另一个函数的返回值def get_function(): s = input(&quot;请输入您要做的操作:&quot;) if s == &apos;求最大&apos;: return max if s == &apos;求最小&apos;: return min if s == &apos;求和&apos;: return sumL = [2, 4, 6, 8, 10]f = get_function()print(f(L)) 函数的嵌套定义: 函数嵌套定义是指一个函数里用def语句来创建其它函数的情况 12345678910# 此示例示意函数嵌套定义def fn_outter(): print(&quot;fn_outter被调用&quot;) def fn_inner(): print(&quot;fn_inner被调用&quot;) fn_inner() # 调用一次 fn_inner() # 调用第二次 print(&quot;fn_outter调用结束!&quot;)fn_outter() python的作用域: 作用域也叫命名空间,是访问变量时查找变量名的范围空间 python的四个作用域: ​ 作用域 英文 英文简写 局部作用域(函数内) Local L 外部嵌套函数作用域 Enclosing function local E 函数定义所在模块作用域 Global G python内建模块的作用域 Builtin(Python) B 123456789101112131415# 此示例示意python的作用域v = 100def f1(): v = 200 print(&quot;f1.v=&quot;, v) def f2(): v = 300 print(&quot;f2.v=&quot;, v) f2()f1()print(&apos;全局的v=&apos;, v)#f1.v= 200#f2.v= 300#全局的v= 100 变量名的查找规则 在访问变量时,先查找本地变量,然后是包裹此函数外部的函数内部的变量,之后是全局变量,最后是内建变量. ​ 即: L –&gt; E –&gt; G –&gt; B 在默认的情况下,变量名赋值会创建或者改变本地作用域内的变量 练习: 得到下列程序运行的结果,思考为什么? L = [1, 2] def f1(): ​ L = [3, 4, 5] f1() print(L) # [1, 2] 因为f1()只制造了局部变量 def f2(): ​ L += [3, 4, 5] # L = L + [3, 4, 5] f2() print(L) # 出错 def f3(): ​ L[:] = [3, 4, 5] f3() print(L) # [3, 4, 5] global 语句 作用: ​ 告诉解释执行器,global 语句声明的一个或多个变量,这些变量的作用域为模块级作用域(也称作全局变量) ​ 全局声明(global) 将赋值语句的变量映射到模块文件内部的作用域 语法: ​ global 变量1, 变量2, …. 12345678910# 此示示意global语句的用法v = 100def f1(): global v # 全局声明 v = 200f1()print(&apos;v=&apos;, v) # ???#200 说明: ​ \1. 全局变量如果要在函数内部被赋值,则必须经过全局声明,否则会被认为是局部变量 ​ \2. 全局变量在函数内部不经过全局声明就可以访问(取值) ​ \3. 不能先声明局部变量,再用global声明为全局变量,此做法不附合规则 ​ \4. global变量列表里的变量名不能出现在函数的形参列表里 练习: 写一个函数hello,部分代码如下: ​ count = 0 ​ def hello(name): ​ print(“你好”, name) ​ … 此处略 当调用hello函数时,全局变量count自动做加1操作来记录hello被调用的次数 如: ​ hello(“Tom”) ​ hello(“Jerry”) ​ print(“hello函数共被调用%d次” % count) # 2 ​ 1234567891011121314151617count = 0def hello(name): print(&quot;你好&quot;, name) global count # 全局声明 count += 1hello(&quot;Tom&quot;)hello(&quot;Jerry&quot;)print(&quot;hello函数共被调用%d次&quot; % count) # 2hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)print(&quot;hello函数共被调用%d次&quot; % count) # 8 nonlocal语句 作用: ​ 告诉解释执行器,nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量 语法: ​ nonlocal 变量名1, 变量名2, … 123456789101112131415161718192021# 此示例示意nonlocal的用法var = 100def f1(): var = 200 print(&quot;f1.var=&quot;, var) # 200 def f2(): nonlocal var var = 300 # 想修改f1里的var为300 print(&quot;f2.var=&quot;, var) # 300 f2() print(&quot;f1.var=&quot;, var) # 300f1()print(&quot;全局的var=&quot;, var)#f1.var= 200#f2.var= 300#f1.var= 300#全局的var= 100 说明: ​ \1. nonlocal 语句只能在嵌套函数内部进行使用 ​ \2. 对nonlocal变量列表内的变量赋值将对外部嵌套函数作用域内的变量进行操作 ​ \3. 当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近的一层的变量进行操作 ​ \4. nonlocal语句变量列表里的变量名,不能出现在此函数的形参列表中 问题: def 语句的作用 lambda 表达式(又名匿名函数) 作用: ​ 创建一个匿名函数对象,同def类似,但不提供函数名 语法: ​ lambda [函数形参列表]: 表达式 123456789# def myadd(x, y):# return x + y# 可以用lambda改写如下:# myadd = lambda x, y: x + ymyadd = lambda *args : sum(args)print(&quot;20+30=&quot;, myadd(20, 30)) # 50print(&quot;100+200=&quot;, myadd(100, 200)) # 300 说明: ​ lambda 表达式创建的函数只能包含一条表达式且直接返回表达式的值 ​ lambda 比函数简单,且可以随时创建和销毁,有利于减少程序的偶合度 ​ def xxx ([函数形参列表]): ​ return 表达式 练习: \1. 写一个lambda表达式: ​ fx = lambda n: … ​ 此表达式创建的函数判断n这个数的2次方+1能否被5整除,如果能整除返回True,否则返回False ​ 如: ​ print(fx(3)) # True ​ print(fx(4)) # False 12345# fx = lambda n: (n ** 2 + 1) % 5 == 0fx = lambda n: True if (n ** 2 + 1) % 5 == 0 else Falseprint(fx(3)) # Trueprint(fx(4)) # False \2. 写一个lambda表达式来创建函数,此函数返回两个形参变量的最大值 ​ def mymax(x, y): ​ … ​ ​ mymax = lambda … ​ print(mymax(100, 200)) # 200 ​ print(mymax(“ABC”, “123”)) # ABC 12345# mymax = lambda x, y: max(x, y)mymax = lambda x, y: x if x &gt; y else yprint(mymax(100, 200)) # 200print(mymax(&quot;ABC&quot;, &quot;123&quot;)) # ABC eval() 和 exec() 函数 eval 函数 作用: ​ 把一个字符串当表达式来执行,返回表达式执行后的结果 格式: ​ eval(source, global=None, local=None) 示例: ​ s = “1 + 2 * 3” ​ v = eval(s) # v = 7 ​ print(v) # 7 ​ x = 100 ​ y = 200 ​ s = “x + y” ​ v = eval(s) # v = 300 12345678910111213# 此示例示意eval函数的参数的用法x = 100y = 200s = &quot;x + y&quot;v = eval(s)print(v) # 300# 假设局部作用域内有 x =1 ; y = 2v2 = eval(s, None, &#123;&apos;x&apos;:1, &apos;y&apos;: 2&#125;)print(v2) # 3# 设置局部作用域内有y=2,全局作用域: x=10,y=20v3 = eval(s, &#123;&apos;x&apos;:10, &apos;y&apos;:20&#125;, &#123;&apos;y&apos;:2&#125;)print(&apos;v3=&apos;, v3) # 12 exec 函数 作用: ​ 把一个字符串当程序来执行 格式: ​ exec(source, global=None, local=None) 示例: ​ s = “x=100\ny=200\nprint(‘x+y=’,x+y)” ​ exec(s) ​ s = “print(x+y)\nprint(x*y)” ​ exec(s, {‘x’:10, ‘y’:20}, {‘y’:2}) 练习: \1. 看懂下面的程序在做什么 ​ def fx(f, x, y): ​ print(f(x, y)) ​ fx((lambda a, b: a + b), 100, 200) ​ fx((lambda a, b: a**b), 3, 4) \2. 给出一个整数n,写一个函数来计算 ​ 1 + 2 + 3 + 4 + … + n 的值并返回结果 ​ 要求用函数来做 123456789101112# 方法1# def mysum(n):# s = 0# for x in range(1, n + 1):# s += x# return sdef mysum(n): return sum(range(1, n + 1))print(mysum(100)) # 5050print(mysum(10)) # 55 \3. 给出一个整数n,写一个函数来计算n!(n的阶乘)) ​ n! = 1234…*n 12345678def myfac(n): s = 1 for x in range(1, n + 1): s *= x return sprint(myfac(5)) # 120 \4. 给出一个整数n,写一个函数来计算 ​ 1+22+33+…+ n**n的和 ​ (n给一个小点的数) 12345678910111213141516# 方法 1# def f(n):# s = 0# for x in range(1, n + 1):# s += x ** x# return s# 方法2def f(n): return sum(map( lambda x:x**x, range(1, n+1) ))print(&quot;f(2) = &quot;, f(2))print(&quot;f(5) = &quot;, f(5)) \5. 写程序打印杨辉三解(只打印6层) ​ 1 ​ 1 1 ​ 1 2 1 ​ 1 3 3 1 ​ 1 4 6 4 1 ​ 1 5 10 10 5 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 第一步,制造相应的列表def get_next_list(L): # 用给定的一行L ,返回下一行 # 如L为[1, 2, 1] 则返回 [1, 3, 3, 1] rl = [1] # 最左边的1 # 算中间的数字(循环获取从0开始的索引) for i in range(len(L) - 1): v = L[i] + L[i + 1] rl.append(v) rl.append(1) # 最右边的1 return rl# 第二步,生成全部的行放到一个整体的列表rl中,并返回def yh_list(n): # n为行数 # 如果 n为3 最终返回的列表是: # [[1],[1, 1], [1, 2, 1]] rl = [] L = [1] while len(rl) &lt; n: rl.append(L) # 加入当前行 # 计算出下一行准备加入 L = get_next_list(L) return rl# 第三步,把杨辉三解的列表转为字符串列表# 如果给定的列表是[[1], [1, 1], [1, 2, 1]]# 返回 [&apos;1&apos;, &apos;1 1&apos;, &apos;1 2 1&apos;]def get_yh_string(L): rl = [] for line in L: # line = [1, 2, 1] -&gt; s = &apos;1 2 1&apos; str_lst = [str(x) for x in line] # str_lst = [&apos;1&apos;, &apos;2&apos;, &apos;1&apos;] s = &apos; &apos;.join(str_lst) rl.append(s) return rl# 打印杨辉三解def print_yh_triangle(L): # L = [&apos;1&apos;, &apos;1 1&apos;, &apos;1 2 1&apos;] max_len = len(L[-1]) for s in L: print(s.center(max_len))L = yh_list(10)SL = get_yh_string(L)print_yh_triangle(SL)]]></content>
      <categories>
        <category>python函数</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2019%2F01%2F05%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&lt;&lt; Python语言 编程基础 &gt;&gt;python简介诞生 ​ 创建人: Guido Van Rossum ​ 时间: 1989 python应用领域:​ 系统运维,网络编程,科学计算,人工智能,机器人,web开发 ​ 云计算,大数据及数据库编程,教育,游戏，图像等 Python的优缺点: 优点: ​ 面向对象(Java, C++, Python, C#， Swift) ​ 免费 ​ 可移植(Windows/Linux/Unix) ​ 可混合编程(C/C++/Java/.net) ​ 简单易学易用 ​ 开发效率高 ​ 应用领域广泛 ​ 开源 缺点: ​ 与C/C++相比，执行速度不够快,不能封闭源代码 python 的官网: https://www.python.org python的版本: ​ Python V2.7 (2020年结束维护) ​ Python V3.5 (当前教学版本) ​ Python V3.8 (最新) 下载地址: http://www.python.org/getit python的安装：可以安装在Linux/Unix/Windows下 python 的运行 python的解释执行器的类型: ​ CPython (C语言开发) ​ Jython (Java开发) ​ IronPython(.net开发) 第一个Python程序 Visual Studio Code使用 编写 hello.py 写入（左侧不能加空格）: ​ print(“hello world!”) 执行程序 : 在终端内: ​ $ python3 文件路径名.py python文件的后缀 .py 为python语言后缀 .c C语言文件后缀 .cpp/.cxx/.cc/.C C++语言后缀 .java Java语言后缀 在python的交互模式下编写并执行代码 进入交互模式: $ python3 &lt;回车&gt; 退出交互模式: ​ >&gt;&gt; quit() &lt;回车&gt; ​ >&gt;&gt; exit() &lt;回车&gt; ​ >&gt;&gt; &lt;输入ctrl + d&gt; python的注释:以 # 开头直至行尾 作用: ​ 让注释内容不参加解释执行 vs code 快捷键: ctrl + / python 程序的组成: 程序由模块组成 模块由语句，函数，类等组成 语句包含表达式 表达式建立并创建数据对象 python中自动化内存管理a = 1000 b = 2000 a = a + b # 释放1000这个对象,a重新绑定在3000上 c = a # c同时绑定在3000上 在交互模式下，查看当前作用域内的所有变量:>&gt;&gt; help(‘main‘)Python的核心数据类型: 数字(整数,浮点型数, 复数，布尔型数(bool)),字符串,列表等 整型数 int 整型数是不带小数部分的数字，包括自然数和负数自然数 如: -5, 100, 0等 整型数的字面值的表示方式: 十进制表示 ​ 如: ​ 10 ​ 200 ​ 9999999999999999 ​ -100 ​ 0 八进制方式表示(0o开头，后跟0~7) ​ 如: ​ 0o177 (127) ​ 0o11 (9) 十六进制方式表示(0x开头,后跟0~9,A-F,a-f) ​ 如: ​ 0x11 # (17) ​ 0xFF # (255) ​ 0x0a # 10 ​ 0x1a2b3c4d 二进制表示方式(0b开头，后跟 0~1) ​ 如: ​ 0b0000 # 0 ​ 0b0001 # 1 ​ 0b0010 # 2 ​ 0b01001000 # 72 进制转换: 十进制: 逢十进一 二进制: 逢二进一 …… 浮点型数 float 浮点数是带有小数部分的数字(小数部分可以为0) 浮点数字面值的表示方式: 小数表示: ​ 如: ​ 3.14 3.1 3. 0.14 .14 科学计数法:​ 格式: ​ 小数 e/E 正负号 指数 ​ 如: ​ 6.18E-1 # 等同于0.618 ​ 2.9979e8 # 等同于299790000.0 复数的表示方式: complex 分为两部分: ​ 实部(real) ​ 虚部(image) 如: ​ 1j ​ 1+2j ​ -2j ​ (-100+200j) 注: 虚部以 J 或 j结尾的数 布尔型数 bool (boolean)用来表示真和假两种状态的类型 ​ True 表示真(条件满足或成立) ​ False 表示假(条件不满足或不成立) 说明: ​ True 的值为1 ​ False 的值为0 空值 None None是一个表示不存在的特殊对象 作用: ​ 用来占位 ​ 变量解除绑定 表达式和运算符(也叫操作符) 算术运算符: \+ 加法 \- 减法 * 乘法 / 除法 // 地板除 % 求余 ** 幂运算 / 除法 除法得到的数是浮点数，不会丢弃小数部分 如: ​ 1 / 3 得 0.333333333333333 ​ 8 / 2 得 4.0 // 地板除 floordiv 除的结果去掉小数部分向下取整 如: 7 / 3 得 2.33333333333333 ​ 7 // 3 得 2 ​ 8 // 3 得 2 ​ 3.25 // 1.5 # 得 2.0 % 求余 7 % 3 得 1 3.25 % 1.5 得 0.25 ** 幂运算 x ** y 表示 x 的 y次方 如: ​ 4 ** 2 # 得 16 ​ 3.0 ** 4.0 # 得 81.0 ​ 5.6 ** 1.418 # 11.506165654866916 运算符的优先级:** \* / % // \+ - 示例: 1 + 3 * 3 ** 2 + 4 // 2 1 + 3 * 9 + 4 // 2 1 + 27 + 4 // 2 1 + 27 + 2 ​ 28 + 2 30 括号分组子表达式 用() 可以将表达式分组，()内部的表达式先进行计算 混合类型自动升级 1 +2.14 返回类型为浮点数 3.14 is / is not 运算符 作用: ​ 判断两个对象是否是同一个对象,当是同一对象时返回True,否则返回False 注: ​ is not 返回值与is 相反 语法: ​ x is y ​ # 或 ​ x is not y id(x) 函数: 作用: ​ 返回一个对象在内存的中的地址 如: ​ a = 10000 ​ b = 10000 ​ print(id(a)) ​ print(id(b)) ​ print(id(a is b)) # True or False? 小整数对象池 CPython中 整数 -5 至 256 的整数永远存在于小整数对象池中，不会释放并一直可用 复合赋值算术运算符:运算符 说明 y += x 等同于 y = y + x y -= x 等同于 y = y - x y *= x 等同于 y = y * x y /= x 等同于 y = y / x y //= x 等同于 y = y // x y %= x 等同于 y = y % x 比较运算符: &lt; 小于 &lt;= 小于等于 \&gt; 大于 \&gt;= 大于等于 == 等于 != 不等于 语法: ​ 左表达式 &lt; 右表达式 说明: ​ 比较运算符返回布尔类型的值 例: ​ 100 &lt; 200 # 返回True ​ 100 &gt;= 200 # 返回False 比较运算符的数据表示：0 &lt;= 30 &lt; 100 # 布尔运算:运算符: ​ not and or 布尔非操作 not 语法: ​ not x 作用: ​ 对x进行布尔取非,如bool(x) 为True,则返回False,否则返回True 示例: ​ not True # False ​ not False # True ​ not 0 # True ​ not 100 # False 布尔与操作 and 语法: ​ x and y ​ 注: x, 代表表达式 作用: ​ 优先返回假值对象,当x的布尔值为False时返回x,否则返回y 示例: ​ True and True # True ​ True and False # False ​ False and True # False ​ False and False # False 布尔或操作 or 语法: ​ x or y来绑定 作用: ​ 优先返回真值对象,如果x为True时返回x,否则返回y 示例: ​ True or True # True ​ True or False # True ​ False or True # True ​ False or False # False 正负号运算+(正号) -(负号) 一元运算符(只有一个元素参加运算) 示例: ​ a = 5 ​ b = -a # b = -5 ​ c = +a # c = 5 数据对象的构造(创建)函数float(obj) 用字符串或数字转换为浮点数，如果不给出参数，则返回0 int(x,base=10) int(x=0) 用数字或字符串转换为整数，如果不给出参数，则返回0 complex(r=0.0, i=0.0) 用数字创建一个复数(实部为r,虚部为i) bool(x) 用x创建一个布尔值(True/False) 函数调用函数名(传参列表) ​ 说明: 函数调用是表达式，一定会返回一个对象的引用关系(或者返回None) bool(x) 返回假值的情况: None 空值 False 布尔假值 0 0.0 0j 所有的数字0 &apos; &apos; 空字符串 ( ) 空元组 [ ] 空列表 { } 空字典 ... 预置(内建)的数值型函数 abs(x) 取x的绝对值 round(number[,ndigits]) 对数值进行”四舍五入”, ndigits是小数向右取整的位数,负数表示向左取整 pow(x, y, z=None) 相当于 xy 或 xy%z help() 查看函数绑助 >&gt;&gt; help(函数名) 变量 什么是变量 ​ 变量是关联一个对象的标识符 ​ 变量可以绑定一个对象，并可能通过变量名来使用这个对象 标识符的命名方法 标识符必须为字母或下划线开头，后跟字母或下划线或数字 不能使用python的关键字 变量名区分大小写 合法的变量名示例: a a1 a100 bbbbb hello _abc var A1B2 a_b_c 不合法的变量名示例: 1a 123 $abc +a #abc True python的关键字不能作为变量名: True, False, None, is, del, if, while,for .... 赋值语句语法: ​ 变量名 = 表达式 ​ # 或 ​ 变量名1 = 变量名2 = 变量名3 = 表达式 ​ # 或 ​ 变量名1, 变量名2, … = 数值1, 数值2,… 作用: ​ 创建一个变量或修改一个变量绑定的数据 说明: ​ \1. 当变量不存在时，创建该变量，同时将变量绑定在表达式返回的对象上 ​ \2. 当变量存在时，改变此变量绑定的对象 ​ \3. 一个变量只能绑定一个对象 ​ \4. 两个变量可以同时绑定在同一个对象上 示例: ​ pi = 3.1415926 ​ a = 10 ​ b = a # a和b 同时绑定在一个10上 python 中关联, 绑定，引用的含义 在python中，变量是没有类型 关联，绑定，引用都是指变量和一个对象的关联关系 示例: a = 10 + 20 a = b = c = 100 # a,b,c三个变量同时绑定在100上 a, b, c = 100, 200, 300 # 序列赋值 序列赋值的语法:变量名1, 变量名2, ... = 对象1, 对象2, ... 变量名1, 变量名2, ... = [对象1, 对象2,...] 变量名1, 变量名2, ... = (对象1, 对象2,...) 表达式 expression 由一个数字 或 数字和运算符组成 作用: ​ 让计算机做事情并返回结果(一定会返回结果) 示例: ​ 1 ​ 1 + 2 # 返回一个3(创建或生成一个3) del 语句 作用: ​ 用于删除变量,同时解除与对象的关联关系，如果可能则释放对象 语法: ​ del 变量名1, 变量名2, …. 自动化内存管理和引用计数 每个对象都会记录有几个变量绑定(引用)自身，当引用数量为0时， 则此对象被销毁，此种自动化内存管理的方式叫做引用计数 语句 statement 语句是python执行的最小单位 语句由一些表达式组成,通常一条语句可以独立执行来完成一部分事情并形成结果 ​ (一条语句建议写在一行内),多条语句写在一行内需要用分号(;) 分开 示例: print(&quot;hello&quot;) ​ x = 100 + 200 ​ # 写在一起为: ​ print(“hello”); x = 100 + 200 语句的显示换行 折行符 \ (读作:反斜杠) ​ 折行符必须放在一行的末尾,来示意解释执行器,下一行也是本行的语句 语句的隐式换行所有的括号的内容换行称为隐式换行 括号: ( ) [ ] { } 基本输入函数 input 作用: ​ 从标准输入设备上(默认为键盘)读取一个字符串 ​ (末尾的换行字符会被删除) 格式: ​ input(‘提示字符串’) 说明: ​ 返回输入的字符串(仅python3) ​ ‘提示字符串’可以省略不写 基本输出函数print 作用: ​ 将一系列的值以字符串形式输出到标准输出设备上(默认是终端) 格式: ​ print(value,…, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False) 关键字参数: ​ sep 两个值之间的分隔符,默认为一个空格’ ‘ ​ sep 输出完毕后在字符流末尾自动追加一个字符串,默认为换行符’\n’ ​ file: 文件流对象，默认为(sys.stdout) ​ flush: 是否立即进行输出 python3中常用于序列的函数:len(x) 返回序列长度 max(x) 返回序最的最大值元素 min(x) 返回序列的最小值元素 sum(x) 返回序列中所有元素的和(元素必须是数值类型) any(x) 真值测试,如果序列中其中一个值为真值则返回True all(x) 真值测试,如果列表中所有值为真值才返回True 示例: ​ L = [‘One’, 2, ‘三’] ​ print(len(L)) # 3 ​ L = [8, 3, 6, 2] ​ min(L) # 2 ​ max(L) # 8 ​ sum(L) # 19 ​ all( [True, 1, 0.01, [1,2,3], “hello”]) # True ​ all( [None, False, 1, 0.01, [1,2,3], “hello”]) # False ​ any( [None, False, 0, 0.0, [], ‘’, “hello”]) # True ​ any( [None, False, 0, 0.0, [], ‘’]) # False 阶段总结:​ 数据类型 ​ 不可变数据类型 ​ bool, int, float, complex, str, tuple, frozenset, bytes(字节串) ​ 可变数据类型 ​ list, dict, set, bytearray(字节数组) 运算符:​ + - * / // % ** ​ > &gt;= &lt; &lt;= == != ​ is / is not ​ in / not in ​ not and or ​ &amp; ^ | ​ + (正号), - (负号) ​ [ ] 索引/切片 表达式:1 1 + 2 max(1,2,3) + max(4,5,6) print(&quot;hello&quot;) 条件表达式 x if x &gt; y else y 全部的推导式: 列表,字典,集合推导式(三种) 语句: 表达式语句:print(&quot;hello&quot;) 赋值语句:a = 100,a = b = c = 200,x, y = 100, 200 del语句,if 语句,while语句,for语句,break语句,continue语句,pass语句 内建函数: \- 用于容器的函数:len(x),max(x),min(x),sum(x),any(x),all(x) \- 构造函数:int(x),bool(x),float(x),complex(x),str(x),list(x),tuple(x),dict(x),set(x),frozenset(x) ​ - 数值处理函数:abs(x),round(x),pow(x, y, z=None) \- 进制字符串:bin(x),oct(x),hex(x) \- 编码转换:chr(x),ord(x) \- 返回可迭代对象的函数:range(start, stop, step),reversed(x) \- 输入输出函数:input(),print(...., sep=&apos; &apos;, end=&apos;\n&apos;) \- 其它:id(x),type(x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】hexo next主题优化手册]]></title>
    <url>%2F2019%2F01%2F02%2F%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91hexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[hexo常见操作hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 next主题优化next风格选择next有四种风格,在站点配置文件搜索字段Scheme Settings可以看到， # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 我这里用的是四种：Gemini next菜单设置比如可以看到我的主页有首页、留言、分类、归档、标签等菜单，在站点配置文件下搜索menu:,可以看到 menu: home: / || home about: /about/ || user message: /message/ || comment tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat home就是首页;message就是留言…一开始只有首页和归档,其余的需要我们手动创建，在站点根目录下打开命令行,输入hexo new page &quot;about&quot;并在主题配置文件menu:字段处取消对about的注释重新部署我们就可以看到主页有关于这个菜单了，其他的类似，修改D:\hexoblog\source\about\index.md,就可以修改关于界面了about: /about/ || user中的user是指关于菜单附件的图标用的是图标库里面名为user的图标 添加萌妹子动图在根目录下打开命令行输入npm install --save hexo-helper-live2d 修改站点配置文件(注意不是主题配置文件)在末尾加入: live2d: enable: true scriptFrom: local model: ​ scale: 1​ hHeadPos: 0.5​ vHeadPos: 0.618 display:​ superSample: 2​ width: 150​ height: 300​ position: right​ hOffset: 0​ vOffset: -20 mobile:​ show: false react:​ opacityDefault: 0.5​ opacityOnHover: 0. 实现文章首页”分类于”、”阅读次数”等效果效果图如下: 在根目录下打开命令行依次输入以下命令:​ npm install hexo-wordcount –save npm uninstall hexo-generator-index –save npm install hexo-generator-index-pin-top –save 打开主题配置文件打开相关开关:​ post_wordcount: item_text: true wordcount: true min2read: true totalcount: true 打开…/themes/next/layout/_macro/post.swig文件把里面的代码用下面的代码替换:点击下载 打开…/themes/next/languages/zh-Hans.yml文件搜索post字段,添加一行comments: 评论数,注意其余的不要改 设置某篇文章置顶前面的流程走完后,只需要在写文章的时候在文章前面加入top: true或者top: 100(100只是个例子，数字越大越靠前),就能实现置顶效果了 常见错误本地预览和同时发布到远程的浏览结果不一致这是由缓存造成的,需要先hexo clean,再hexo g -d部署到远程 markdown高级语法插入连续多行的代码块按一个tab键,然后贴代码，保证每一行代码前都要额外的tab键,同时最前面空一行。比如,我前面插入的连续行代码的实现效果: 设置文字大小和颜色和居中效果hello,world! hello,world! hello,world! hello,world! hello,world!上面的效果需要在markdwon中的代码是这样的: hello,world! &lt;font color=&quot;#FF0000&quot;&gt; hello,world! &lt;/font&gt; &lt;font size=5&gt; hello,world! &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt;hello,world! &lt;/font&gt; &lt;center&gt;hello,world!&lt;/center&gt; 插入表格效果图: 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 markdown代码如下： | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 |]]></content>
  </entry>
</search>
