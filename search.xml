<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python之异常]]></title>
    <url>%2F2019%2F02%2F15%2Fpython%E4%B9%8B%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常(基础) exception 什么是错误 错误是指由于逻辑或语法等导致一个程序无法正常执行的问题 什么是异常 异常是程序出错误时标识的一种状态 当异常发生时,程序不会再向下执行,而转去调用此函数的地方待处理此错误并恢复为正常状态 作用: 用作信号,通知上层调用者有错误产生需要处理 try语句: 两种语法: ​ try-except 语句 ​ try-finally 语句 try-except语句 语法: ​ try: ​ 可能触发异常的语句 ​ except 错误类型1 [as 变量名1]: ​ 异常处理语句1 ​ except 错误类型2 [as 变量名2]: ​ 异常处理语句2 ​ except (错误类型3, 错误类型4)[as 变量3]: ​ 异常处理语句3 ​ except: ​ 异常处理语句other ​ else: ​ 末发生异常语句 ​ finally: ​ 最终语句 作用: ​ 偿试捕获异常通知,将程序由异常流程转为正常流程并继续执行 说明: ​ except 子句可以有一个或多个,但至少要有一个 123456789101112131415161718# 此示例示意try-except 语句的基本语法和用法def div_apple(n): print(&quot;有%d个苹果,您想分给几个人?&quot; % n) s = input(&quot;请输入人数: &quot;) count = int(s) #可能触发ValueError错误 result = n / count #ZeroDivisionError print(&quot;每个人分了%d个苹果&quot; % result)try: div_apple(10)except ValueError: print(&quot;分苹果时发生值错误异常,已捕获并转为正常状态&quot;) print(&quot;把苹果拿回来&quot;)except ZeroDivisionError: print(&quot;没有人来拿苹果,苹果被收回&quot;)print(&quot;程序正常结束&quot;) 1234567891011121314151617def div_apple(n): print(&quot;有%d个苹果,您想分给几个人?&quot; % n) s = input(&quot;请输入人数: &quot;) count = int(s) #可能触发ValueError错误 result = n / count #ZeroDivisionError print(&quot;每个人分了%d个苹果&quot; % result)try: div_apple(10)except ValueError as err: print(&quot;分苹果时发生值错误&quot;) print(&quot;发生错误的原因是:&quot;, err) print(&quot;把苹果拿回来&quot;)except ZeroDivisionError: print(&quot;没有人来拿苹果,苹果被收回&quot;)print(&quot;程序正常结束&quot;) 练习: 写一个函数 get_score() 来获取学生输入的成绩(0 ~ 100) 的数,如果用户输入的不是0~100的整数则返回0,否则返回输入的整数 如: ​ def get_score(): ​ … ​ score = get_score() ​ print(“您输入的成绩是:”, score) 12345678910111213# 方法1 在调用get_score时加入try语句def get_score(): s = int(input(&quot;请输入成绩(0~100): &quot;)) if not (0 &lt;= s &lt;= 100): return 0 return stry: score = get_score()except ValueError: # 如果末获取到学生信息,则此时学生成绩为0 score = 0print(&quot;您输入的成绩是:&quot;, score) 12345678910111213# 方法2 在get_score函数内部加入try语句来进行错误处理def get_score(): try: s = int(input(&quot;请输入成绩(0~100): &quot;)) except ValueError: return 0 if not (0 &lt;= s &lt;= 100): return 0 return sscore = get_score()print(&quot;您输入的成绩是:&quot;, score) try-finally 语句 语法: ​ try: ​ 可能触发异常的语句 ​ finally: ​ 最终语句 说明: ​ finally 子句不可以省略 ​ 一定不在存在except 子句 作用: ​ \1. 通常用try-finally 语句来做触发异常时必须要处理的事情,无论异常是否发生,finally子句都会被执行 ​ \2. try-finally 语句不会改变程序的(正常/异常)状态 1234567891011121314# 此示例示意,try-finally语句用法# 以煎蛋, 打开天燃气, 关闭天燃气def fry_egg(): print(&quot;打开天燃气...&quot;) try: count = int(input(&quot;请输入鸡蛋个数:&quot;)) print(&quot;完成煎蛋,共煎了%d个鸡蛋&quot; % count) finally: print(&quot;关闭天燃气&quot;)try: fry_egg()except: print(&quot;煎鸡蛋时发生异常, 已转为正常状态&quot;) raise 语句 作用: ​ 触发一个错误,让程序进入异常状态 ​ 发送错误通知给调用者 语法: ​ raise 异常类型 ​ # 或 ​ raise 异常对象 ​ # 或 ​ raise # 重新触发上一次异常 1234567891011121314151617181920# 此示例示意raise 发送错误通知的用法def make_except(): print(&quot;函数开始&quot;) # 发出ZeroDivisionError类型的错误给调用者 # raise ZeroDivisionError # raise ValueError e = ValueError(&quot;值错误&quot;) #创建一个错误对象 raise e print(&quot;函数结束&quot;)try: make_except()except ZeroDivisionError: print(&quot;接收到make_except发出的错误通知&quot;)except ValueError as err: print(&quot;ValueError---&gt;&quot;, err)print(&quot;程序正常结束&quot;) 12345678910111213141516171819202122# 此示例示意raise 无参用法def fa(): print(&quot;---fa---开始&quot;) raise ValueError(&quot;故意制造的一个错误!&quot;) # int(&quot;aaaa&quot;) print(&quot;---fa---结束&quot;)def fb(): print(&quot;fb开始&quot;) try: fa() except ValueError as err: print(&quot;fa里发生了值错误已处理&quot;) # 此处如果要将err再次向上传递 raise print(&quot;fb结束&quot;)try: fb()except ValueError: print(&quot;再一次收到fb内部发生的错误 &quot;) 练习: 写一个函数get_age() 用来获取一个人的年龄信息 此函数规定用户只能输入1~140之间的整数,如果用户输入的数是其它的数值,则直接触发ValueError类型的错误! 如 : ​ def get_age(): ​ … ​ ​ try: ​ age = get_age() ​ print(“用户输入的年龄是”, age) ​ except ValueError as err: ​ print(“用户输入的不是1~140的数字,获取年龄失败”) 12345678910111213141516def get_age(): try: a = int(input(&quot;请输入年龄: &quot;)) except ValueError: raise ValueError(&quot;用户输入的不是数字&quot;) if a &lt; 1: raise ValueError(&quot;用户输入的年龄太小&quot;) if a &gt; 140: raise ValueError(&quot;用户输入的年龄太大&quot;) return atry: age = get_age() print(&quot;用户输入的年龄是&quot;, age)except ValueError as err: print(&quot;用户输入的不是1~140的数字,获取年龄失败&quot;) print(&quot;err=&quot;, err) assert 语句(断言语句) 语法: ​ assert 真值表达式, 错误数据(通常是字符串) 作用: ​ 当真值表达式为False时,用错误数据创建一个AssertionError类型的错误,并进入异常状态 等同于: ​ if bool(真值表达式) == False: ​ raise AssertionError(错误数据) 1234567891011121314# 此示例示意assert 语句的用法:def get_score(): s = int(input(&quot;请输入学生成绩:(0~100): &quot;)) assert 0 &lt;= s &lt;= 100, &quot;成绩超出范围&quot; # if bool(0 &lt;= s &lt;= 100) == False: # raise AssertionError(&quot;成绩超出范围&quot;) return stry: score = get_score() print(&quot;学生的成绩为:&quot;, score)except AssertionError as err: print(&quot;AssertionError类型的错误被触发,且已捕获&quot;) print(&quot;err=&quot;, err) 小结: 异常处理相关的语句: ​ try-except 语句: ​ 作用: ​ 捕获异常通知,将程序由异常状态转为正常状态 ​ try-finally 语句 ​ 作用: ​ 执行必须要执行的语句 ​ raise 语句 ​ 作用: ​ 触发异常(抛出异常),让程序进入异常流程 ​ assert 语句 ​ 作用: ​ 根据条件来触发AssertionError类的异常并进入异常流程 异常(高级) with 语句 ​ 语法: ​ with 表达式1 [as 变量1], 表达式2 [as 变量2], …: ​ 语句块 作用: ​ 使用于对资源进行访问的场合,确保使用过程中不管是否发生异常都会执行必须的’清理’操作, 并释放资源 ​ 如:文件打开后自动关闭,线程中锁的自动获取和释放等(线程后面会学) 说明: ​ as 子句中的变量用于绑定表达式执行后生成的对象 ​ with语句并不会改变异常的状态 123456789101112# 第一种方式用try-finally保证文件一定能够正常关闭try: f = open(&quot;../../day19/day19.txt&quot;) try: for l in f: x = int(&apos;aaaa&apos;) # 出现异常 print(l) finally: f.close() print(&quot;文件已经关闭&quot;)except OSError: print(&quot;打开文件失败&quot;) 1with open(&quot;../../day19/day19.txt&quot;) as f: 环境资源管理器 ​ 1. 类内有 enter和 exit实例方法的类创建的对象被称为环境管理器 ​ 2. 能够用with语句进行管理的对象必须是环境管理器 ​ 3. enter方法将在进入with语句时被调用, 由as变量绑定返回的对象 ​ 4. exit方法将在离开with语句时被自动调用,且可以通过参数来判断离开with语句时是否有异常发生 1234567891011121314151617181920212223242526# 此示例示意自定义的对象加入__enter__ 和 __exit__ 方法,让A类的对象能够使用with使用语句class A: &apos;&apos;&apos;此类的对象可以用于with语句进行管理&apos;&apos;&apos; def __enter__(self): print(&quot;此方法是在with语句内执行的&quot;) return self # self将 被 with 中的as 变量绑定 def __exit__(self, exc_type, exc_val, exc_tb): &apos;&apos;&apos;exc_type 用来绑定错误类型,当没有异常发生时绑定None exc_val 用来绑定错误对象,当没有发生异常时绑定None exc_tb 用来绑定TraceBack对象,当没有异常时绑定None &apos;&apos;&apos; if exc_type is None: print(&quot;您已离开with语句,离开时没有发生任何异常&quot;) else: print(&quot;您已离开with语句&quot;) print(&quot;错误类型是:&quot;, exc_type) print(&quot;错误对象是:&quot;, exc_val) print(&apos;Traceback:&apos;, exc_tb)with A() as a: print(&quot;这是with语句内部的输出&quot;) int(input(&quot;请输入整数: &quot;))print(&quot;程序正常结束&quot;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 语句（if,while,for）]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E8%AF%AD%E5%8F%A5%EF%BC%88if-while-for%EF%BC%89%2F</url>
    <content type="text"><![CDATA[if 语句 问题: ​ 有两条语句: ​ print(“是偶数”) ​ print(“是奇数”) ​ 如何只让其中的一条语句执行，另一条不执行 作用: 让程序根据条件选择性的执行某条语句或某些语句 语法: if 真值表达式1: ​ 语句块1 elif 真值表达式2: ​ 语句块2 elif 真值表达式3: ​ 语句块3 …. else: ​ 语句块4 说明: elif 子句可以有0个,1个或多个 else 子句可以有0个或1个，且只能放在此if语句的最后 示例见: 123456# 输入一个数，判断这个数是奇数还是偶数x = int(input(&quot;请输入一个整数: &quot;))if x % 2 == 0: print(&quot;是偶数&quot;)else: print(&quot;是奇数&quot;) 练习: 任意输入一个数 ​ 1) 判断这个数是否大于100 ​ 2) 判断这个数是否小于0 ​ 3) 判断这个数是否在 50 ~ 150 之间 123456789101112# 此示例示意if-elif 语句的用法# 输入一个整数，判断这个数是正数，负数，零num = int(input(&quot;请输入一个整数:&quot;))if num &gt; 0: print(num, &apos;是正数&apos;)elif num &lt; 0: print(num, &apos;是负数&apos;)# elif num == 0:else: print(num, &apos;是零&apos;)print(&quot;程序结束&quot;) 练习: 输入一个季度(1 ~ 4), 输出这个季度有哪儿几个月，如果输入不是1~4的数，则提示用户您输错了 输入一年中的月份(1~12), 输出这个月在哪儿个季度.如果输入的是其它的数，则提示您输错了 if语句的真值表达式: if 100: ​ print(“是真值”) 等同于: if bool(100): ​ pritn(“是真值”) if 语句的嵌套 if 语句本身是由多条语句组成的一条复合语句,if语句可以作为语句嵌套到另一个语句的内部 123456789101112131415161718192021222324252627282930# 此示例示意用if 语句嵌套来实现下面程序的功能n = int(input(&quot;请输入月份(1~12): &quot;))if 1 &lt;= n &lt;= 12: print(&quot;用户输入的是合法的月份&quot;) if n &lt;= 3: print(&quot;春季&quot;) elif n &lt;= 6: print(&quot;夏季&quot;) elif n &lt;= 9: print(&quot;秋季&quot;) else: print(&quot;冬季&quot;)else: print(&quot;您输错了&quot;)# 2. 输入一年中的月份(1~12), 输出这个月在哪儿个季度.如果输入的是其它的数，则提示您输错了# n = int(input(&apos;请输入月份(1～12): &apos;))# if 1 &lt;= n &lt;= 3:# print(&quot;春季&quot;)# elif 4 &lt;= n &lt;= 6:# print(&quot;夏季&quot;)# elif 7 &lt;= n &lt;= 9:# print(&quot;秋季&quot;)# elif 10 &lt;= n &lt;= 12:# print(&quot;冬季&quot;)# else:# print(&quot;您输错了&quot;) 练习: 写一个程序，输入一个数，用if语句计算这个数的绝对值,并打印出来 （要求: 不允许用abs(x) 函数) 123456789x = int(input(&quot;请输入一个整数: &quot;))# if x &gt;= 0:# print(x)# else:# print(-x)if x &lt; 0: x = -xprint(x) 条件表达式: 语法: ​ 表达式1 if 真值表达式 else 表达式2 作用: ​ 根据真值表达式的取值(True/False) 来决定执行表达式1或表达式2并返回结果 示例见: 12345money = int(input(&quot;请输入商品总金额: &quot;))pay = money-20 if money &gt;= 100 else moneyprint(&quot;您需要支付: &quot;, pay, &apos;元&apos;) 练习: 写程序,输入一个数,用条件表达式计算这个数的绝对值并打印出来 1234x = int(input(&quot;请输入一个数: &quot;))x = x if x &gt; 0 else -xprint(&quot;绝对值为:&quot;, x) pass 语句 作用: ​ 通常用来填充语法空白 ​ pass 又名空语句 语法: ​ pass 示例见: 12345678910# 让用户输入一个学生成绩(0~100)之间,判断是否为有效成绩x = int(input(&quot;请输入成绩:&quot;))if 0 &lt;= x &lt;= 100: passelse: print(&quot;输入成绩不合法&quot;)if not (0 &lt;= x &lt;= 100): print(&quot;输入成绩不合法&quot;) print语句1234567891011# 此示例示意print函数的用法print(&quot;hello&quot;)print(1,2,3,4)print(1,2,3,4, sep=&quot;#&quot;)print(1,2,3,4, sep=&quot;+++&quot;)print(111, end=&apos;\n&apos;) # end=&apos;\n&apos;print(100, end=&apos;&apos;) # end=&apos;\n&apos;print(200, end=&apos;&apos;)print() # 打印一个换行print(&quot;aaaaa&quot;, end=&apos;\n\n\n&apos;) # 打印完后空两行print(&apos;bbbbb&apos;) 循环语句 while 语句 for 语句 while语句: 作用: ​ 根据一定条件,重复的执行一条语句或多条语句 语法: ​ while 真值表达式: ​ 语句块1(*此部分的语句可能会重复执行) ​ else: ​ 语句块2 说明: ​ else 子句可以省略(同if类似) 执行步骤: ​ 1. 先执行真值表达式,测试布尔值是否为True或False ​ 2. 如果真值表达式测试值为True, 则执行语句块1,然后再回到第1步 ​ 3. 如果真值表达式测试值为False,则执行else子句中的语句2,然后结束此while语句.如果没有else子句,则直接结束此while语句的执行 12345678i = 1 # 初始化循环变量while i &lt;= 20: # 判断是否要执行其中的语句 print(&quot;hello!&quot;) i += 1 # 改变循环变量i的值来控制循环次数else: print(&quot;这是while里的else子句里的语句&quot;)print(&quot;程序结束&quot;) 练习: 写程序 打印 1 ~ 20的整数,打印在一行显示,每个数字之间用空格分隔 ​ 1 2 3 4 5 6 …… 18 19 20 ​ 提示: ​ print(n, end=’ ‘) 123456i = 1while i &lt;= 20: print(i, end=&apos; &apos;) i += 1print() # 换行 打印1 ~ 20 的整数,每行打印5个,打印4行 12345678i = 1while i &lt;= 20: print(i, end=&apos; &apos;) if i % 5 == 0: print() # 换行 i += 1print() # 换行 输入一个整数,打印一个宽度和高度都是n个字符的长方形 12345678910111213n = int(input(&apos;请输入宽度: &apos;))# 打印第一行print(&quot;#&quot; * n)# 打印中间的 n - 2 行i = 1while i &lt;= n - 2: print(&apos;#&apos; + &apos; &apos; * (n - 2) + &apos;#&apos;) i += 1# 打印最后一行if n &gt; 1: print(&quot;#&quot; * n) 练习: 写程序, 计算: ​ 1 + 2 + 3 + 4 + ….. 100 的和 ​ 并打印结果 ​ 提示: 用一个专用的变量初始化为零,用它来保存和 12345678s = 0 # 此变量用来记录每个加后的结果i = 1while i &lt;= 100: # print(i) s = s + i # s += i i += 1print(&quot;和是:&quot;, s) 写程序. ​ 输入一个开始值用begin绑定 ​ 输入一个结束值用end绑定 ​ 计算: ​ 从begin开始,到end结束的所有整数的和 12345678910begin = int(input(&quot;请输入开始值: &quot;))end = int(input(&quot;请输入结束值: &quot;))s = 0i = beginwhile i &lt;= end: s += i i += 1print(&quot;和是:&quot;, s) 写一个程序 输入一个开始整数值用变量 begin绑定 输入一个结束整数值用变量 end绑定 打印从begin开始到end结束的每个整数,打印在一行内 ​ 如: ​ 请输入开始值: 8 ​ 请输入结束值: 30 ​ 打印: ​ 8 9 10 11 12 13 …. 30 完成后思考: 如何实现每5个整数打印在一行内,打印多行 ​ 提示: 可以多加一个变量来记录打印个数 123456789101112begin = int(input(&quot;请输入开始值: &quot;))end = int(input(&quot;请输入结束值: &quot;))count = 0 # 此变量用来记录已打印的数字个数i = beginwhile i &lt;= end: print(i, end=&apos; &apos;) count += 1 if count % 5 == 0: print() # 换行 i += 1print() # 换行 while 注意事项: \1. 要控制循环的真值表达式来防止死循环 \2. 通常在循环语句块内改变循环变量来控制循环次数和变量的走向 while 语句的嵌套 while 语句本身也是语句,和其它语句一样,可以嵌套到任何复合语句中 示意: ​ while 真值表达式: ​ … ​ while 真值表达式2: ​ … ​ else: ​ … ​ … ​ else: ​ … 示例: 打印 1 ~ 20整数,打印在一行内 ​ 1 2 3 4 5 6 ….. 20 打印以上的十行 1234567891011121314151617j = 0while j &lt; 10: # print(&quot;1 2 3 4 5 ..... 20&quot;) i = 1 while i &lt;= 20: print(i, end=&apos; &apos;) i += 1 print() j += 1# 打印一行# i = 1# while i &lt;= 20:# print(i, end=&apos; &apos;)# i += 1# print() break 语句 问题: ​ 如果在循环过程中,不想再继续执行此循环的执行了,怎么办? 作用: ​ 用于循环语句(while,for语句)中,用来终止当前循环语句的执行 说明: ​ 1. 当break执行后,此循环语句内break之后的语句将不再执行 ​ 2. break 通常和if语句组合使用 ​ 3. break 终止循环时,循环语句的else子句将不会被执行 ​ 4. break 语句只能终止当前循环语句的执行.如果有循环嵌套时,不会跳出外重循环 12345678910111213# 此示例示意循环嵌套j = 1while j &lt;= 10: i = 1 while i &lt;= 20: print(i, end=&apos; &apos;) if i == 10: break i += 1 print() j += 1print(&quot;程序结束&quot;) 死循环 死循环是指条件一直成立的循环 死循环通常用break语句来终止循环 死循环的else子句永远不会执行 死循环通常用在循环次数不确定的循环中 12345while True: n = int(input(&quot;请输入整数:&quot;)) if n == 0: break print(&quot;您输入的是:&quot;, n) 练习: 写一个程序, 任意输入一些整数,当输入小于零的数时结束输入,当输入完成后,打印您输入的这些正整数的和 ​ 如: ​ 请输入: 1 ​ 请输入: 2 ​ 请输入: 3 ​ 请输入: 4 ​ 请输入: -1 ​ 打印: 您刚才输入的这些正整数的和是: 10 练习: 打印从零开始的浮点数,每个数增加0.5,打印出10以内这样的数 ​ 0.0 0.5 1.0 1.5 ….. 9.0 9.5 123456f = 0.0while f &lt; 10: print(f, end=&apos; &apos;) f += 0.5print() # 换行 写程序求: ​ 1/1 + 1/3 + 1/5 + 1/7 + ….. + 1/99的和 1234567fenmu = 1he = 0.0while fenmu &lt; 100: he += 1 / fenmu fenmu += 2print(&quot;和是:&quot;, he) 输入一个整数表示三角形的宽度和高度,打印出如下的三角形: ​ 如: ​ 请输入三解形的宽度: 4 ​ 打印如下: ​ * ​ ** ​ *** ​ ** 1234567n = int(input(&quot;请输入一个三角形的高度: &quot;))line_number = 1while line_number &lt;= n: # print(&quot;第&quot;, line_number, &apos;行&apos;) print(&quot;*&quot; * line_number) line_number += 1 写程序,输入一个整数代表正方形的宽和高,打印如下的正方形: ​ 如: ​ 请输入宽度: 5 ​ 打印正方形如下: ​ 1 2 3 4 5 ​ 2 3 4 5 6 ​ 3 4 5 6 7 ​ 4 5 6 7 8 ​ 5 6 7 8 9 ​ 如: ​ 请输入宽度: 4 ​ 打印正方形如下: ​ 1 2 3 4 ​ 2 3 4 5 ​ 3 4 5 6 ​ 4 5 6 7 12345678910111213w = int(input(&quot;请输入宽度: &quot;))line = 1while line &lt;= w: # print(&quot;这是第&quot;, line, &apos;行&apos;) # 以line为开始打印w个数,打印在一行内 i = line # 起始值是行号 while i &lt; line + w: print(&quot;%02d&quot; % i, end=&apos; &apos;) i += 1 print() # 换行 line += 1 for 语句 作用: ​ 用来遍历可迭代对象的数据元素 可迭代对象: 字符串 str (以下后面会讲) 列表 list 元组 tuple 字典 dict 集合 set … 语法: ​ for 变量列表 in 可迭代对象: ​ 语句块1(重复执行) ​ else: ​ 语句块2 说明: ​ 1. else 子句可以省略(同while类似) ​ 2. 当在循环内部用break终止循环时，else子句部分的语句不会执行 123456# 此示例示意for语句的语法和使用s = &quot;ABCDE&quot;for ch in s: print(&quot;ch---&gt;&quot;, ch)else: print(&quot;遍历字符串&quot;, s, &apos;结束&apos;) 练习: 任意输入一段字符串 ​ 1) 计算这个字符串中’a’ 这个字符的个数,并打印出来 ​ 2) 计算出空格的个数，并打印出来 ​ (要求: 用for语句实现，不允许使用 S.count方法) 思考: ​ 用while语句能否实现上述功能? 123456789101112131415s = input(&quot;请输一段文字: &quot;) count_a = 0 # 此变量用来记录a的个数for ch in s: if ch == &apos;a&apos;: count_a += 1print(&quot;&apos;a&apos;这个字符的个数是:&quot;, count_a)count_blank = 0 # 此变量用来记录空格的个数for ch in s: if ch == &apos; &apos;: count_blank += 1print(&quot;空格的个数是:&quot;, count_blank) range 函数: 作用: ​ 用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器) ​ 函数 说明 range(stop) 用来生成 0~stop 之间内的整数，直到stop为止(不包含stop) range(start, stop[,step]) 用来生成start~stop之间的整数，直到stop为止(不包含stop),每个整数间隔step，且step可以是负数 说明: ​ 此对象可用于for语句来进行迭代取出其中的元素 示例: ​ range(4) # 生成 0 1 2 3 ​ range(3, 6) # 生成 3 4 5 ​ range(1, 10, 2) # 生成 1 3 5 7 9 ​ range(5, 0, -2) # 生成 5 3 1 ​ range(5, 0, -1) # 生成 5 4 3 2 1 1234567891011# 此示例示意range的用法for x in range(4): print(x) # 0 1 2 3 print(&quot;-------------------&quot;)for y in range(3, 6): print(y) # 3, 4, 5print(&apos;===================&apos;)for z in range(1, 10, 2): print(z) 练习: 用for语句打印 1～20的整数，打印在一行内. 用for语句打印 1～20的整数，每行打印5个,打印4行. 1234567891011# 1. 用for语句打印 1～20的整数，打印在一行内.for x in range(1, 21): print(x, end=&apos; &apos;)print()# 2. 用for语句打印 1～20的整数，每行打印5个,打印4行.for x in range(1, 21): print(x, end=&apos; &apos;) if x % 5 == 0: print()print() 求 100 以内有哪儿些数与自身+ 1的乘积再对11求余结果等于8? ​ x * (x+1) % 11 == 8 1234# x * (x+1) % 11 == 8for x in range(100): if x * (x + 1) % 11 == 8: print(x) 输入一段字符串,判断您输入的字符串中有几个中文字符: ​ (注: 中文字符的编码值一定大于127) ​ 提示: 用ord(x) 函数可以返回一个字符的编码值 12345678s = input(&apos;请输入中英文混合的字符串: &apos;)count = 0for c in s: # 遍历每个字符 # 判断c是否是中文 if ord(c) &gt; 127: count += 1print(&quot;中文字符的个数是:&quot;, count) for语句的注意事项: for 语句range调用顺序: 示意: ​ 请问此程序打印的结果是什么?为什么? 1234i = 6 for x in range(1, i): print(&apos;x=&apos;, x, &apos;i=&apos;, i) i -= 1 for语句变量列表里的变量可能不被创建 1234for x in range(4, 0): print(x) else: print(&quot;循环结束后x的值是&quot;, x) # 报错 for语句中用break语句中断执行时,else子句不会执行 123456for x in range(10): print(x) if x == 3: breakelse: print(&quot;for语句结束&quot;) for 语句嵌套: 示例: ​ for x in “ABC”: ​ for y in “123”: ​ print(x + y) 练习: 写一个程序,打印26个大写英文字母 和 26个小写英文字母 ABCDEFG….XYZabcdefg….XYZ chr(i) 数字转为字符 “A” –&gt; 65 ‘a’ –&gt; 97 123456789for code in range(ord(&apos;A&apos;), ord(&apos;Z&apos;) +1): print(chr(code), end=&apos;&apos;)for code in range(ord(&apos;a&apos;), ord(&apos;z&apos;) +1): print(chr(code), end=&apos;&apos;)print() # 换行for code in range(0, 65536): print(chr(code), end=&apos;&apos;) continue 语句 问题: ​ 如何让程序不再向下执行本次循环,重新开始一次新的循环 作用: ​ 用于循环语句(while,for语句)中, 不再执行本次循环内continue之后的语句,重新开始一次新的循环 说明: ​ 1. 在for语句中执行continue语句,将会从可迭代对象中取下一个数据,绑定变量后开始一次新的循环 ​ 2. 在while语句中,执行continue语句,将会直接跳转到while语句真值表达式处,重新判断循环条件 语法: ​ continue 1234567891011121314151617181920212223# continue.pyfor x in range(5): if x == 2: continue print(x) # continue2.py# 跳过奇数,打印10以内的偶数for num in range(10): if num % 2 == 1: continue print(num)# continue3.py# 此示例示意将continue用于while循环中的情况# 用while语句打印 10以内的偶数i = 0while i &lt; 10: if i % 2 == 1: i += 1 continue print(i) i += 1 练习: 输入一个整数代表开始用begin绑定 ​ 输入一个整数代表结束用end绑定 ​ 打印 begin~ end(不包含end) 之间的全部奇数 12345678910111213begin = int(input(&quot;请输入开始值: &quot;))end = int(input(&quot;请输入结束值: &quot;))# 方法1for x in range(begin, end): if x % 2 == 0: continue print(x)# 方法2for x in range(begin, end): if x % 2 == 1: print(x) 求 1~100之间所有不能被2,3,5,7整除的数 ​ 1) 打印这些数 ​ 2) 打印这些数的和 12345678910111213141516171819202122he = 0# for x in range(1, 100):# if x % 2 == 0:# continue# if x % 3 == 0:# continue# if x % 5 == 0:# continue# if x % 7 == 0:# continue# print(x)# he += xfor x in range(1, 100): if (x % 2 == 0 or x % 3 == 0 or x % 5 == 0 or x % 7 == 0): continue print(x) he += x 练习: 写程序输入一个三角形的宽和高,打印相应的三角形: ​ 如: ​ 输入: 3 ​ 1) ​ * ​ ** ​ *** ​ 2) ​ * ​ ** ​ *** ​ 3) ​ *** ​ ** ​ * ​ 4) ​ *** ​ ** ​ * 123456789101112131415161718192021222324252627282930313233343536n = int(input(&quot;请输入三角形的高: &quot;))# 1) # *# **# ***# stars代表星号个数for stars in range(1, n+1): print(&quot;*&quot; * stars)print(&quot;-----------------------&quot;)# 2)# *# **# ***for stars in range(1, n+1): blanks = n - stars # 计算空格个数 print(&apos; &apos; * blanks + &quot;*&quot; * stars)print(&apos;=====================&apos;)# 3)# ***# **# *for stars in range(n, 0, -1): print(&quot;*&quot; * stars)print(&apos;++++++++++++++++++++&apos;)# 4)# ***# **# *for stars in range(n, 0, -1): blanks = n - stars print(&apos; &apos; * blanks + &quot;*&quot; * stars) 写一个程序,任意输入一个整数,判断这个数是否为素数(prime) ​ 素数(也叫质数), 只能被1和自身整除的正整数 ​ 如: 2 3 5 7 11 13 17 …. ​ 153 370 …示: ​ 153 370 …用排除法: 当判断x是否为素数时,只要让x分别除 153 370 …以2, 3, 4, 5… x-1,只要有任何一个数能整数,则说明x不是素数,否则x为素数 12345678910x = int(input(&quot;请输入整数: &quot;))if x &lt; 2: print(x, &apos;不是素数!&apos;)else: for i in range(2, x): if x % i == 0: print(x,&apos;不是素数&apos;) break else: print(x,&apos;是素数&apos;) 3. ​ 编写程序求下列多项式的值: ​ Sn = 1/1 - 1/3 + 1/5 - 1/7 + ….. ​ 1) 求1000000个这样的分数相加的和是多少? ​ 2) 将上一步的和乘以4打印出来,是多少? 1234567891011121314Sn = 0.0fenmu = 1 # 代表分母i = 0 # 控制循环次数sign = 1 # 代表正负符号while i &lt; 100000000: r = sign * 1 / fenmu Sn += r # 累加 sign *= -1 fenmu += 2 i += 1print(&quot;Sn=&quot;, Sn)print(&quot;Sn*4=&quot;, Sn * 4) 算出 100 ~ 999之间的水仙花数(Narcissistic Number) ​ 水仙花数是指百位的3次方 + 十位的3次方 + 个位的3次方等于原数的整数 如: ​ 153 = 13 + 53 + 3**3 ​ 答案: ​ 153 370 … 12345678910111213141516171819202122232425# 方法1# for x in range(100, 1000):# bai = x // 100 # 百位# shi = x % 100 // 10 # 十位# ge = x % 10 # 个位# if x == bai ** 3 + shi ** 3 + ge**3:# print(x)#方法2# for x in range(100, 1000):# s = str(x) # 转为字符串# bai = int(s[0]) # 百位# shi = int(s[1]) # 十位# ge = int(s[2]) # 个位# if x == bai ** 3 + shi ** 3 + ge**3:# print(x)# 方法3for bai in range(1, 10): for shi in range(10): for ge in range(10): # print(bai, shi, ge) x = bai * 10**2 + shi * 10**1 + ge * 10**0 if x == bai ** 3 + shi ** 3 + ge**3: print(x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 集合]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合 set 集合是可变的容器 集合内的数据对象都是唯一的(不能重复多次的) 集合是无序的存储结构,集合中的数据没有先后关系 集合内的元素必须是不可变对象 集合是可迭代对象 集合是相当于只有键没有值的字典(键则是集合的数据) 创建空集合: set() 创建非空集合: s = {1, 2, 3} 集合的构造函数 set set() 创建一个空的集合对象(不能用{}来创建空集合) set(iterable) 用可迭代对象创建一个新的集合对象 示例: ​ s = set() # 空集合 ​ s = {3, 5, 7, 9} ​ s = set(“ABC”) # {‘A’, ‘B’, ‘C’} ​ s = set(“ABCCBA”) # {‘A’, ‘B’, ‘C’} ​ s = set({1:’一’, 2:’二’, 5:’五’}) ​ s = set([1, 2.0, 3.14, False]) ​ s = {True, None, “ABC”, (1,2,3)} 集合的运算: 交集&amp; 并集| 补集- , 对称补集^ 子集&lt; 超集&gt; &amp; 生成两个集合的交集 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 &amp; s2 # s3 = {2, 3} | 生成两个集合的并集 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 | s2 # s3 = {1, 2, 3, 4} - 生成两个集合的补集 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 - s2 # {1} 注: 两个属于s1,但不属于s2的所有元素的集合 ^ 生成两个集合的对称补集 s1 = {1, 2, 3} s2 = {2, 3, 4} s3 = s1 ^ s2 # {1, 4} &lt; 判断一个集合是另一个集合的子集 > 判断一个集合是另一个集合的超集 s1 = {1, 2, 3} s2 = {2, 3} s1 &gt; s2 # True s1为s2的超集 s2 &lt; s1 # True s2为s1的子集 == / != 集合相同/不同 s1 = {1, 2, 3} s2 = {3, 2, 1} s1 == s2 # True s1 != s2 # False >= &lt;= 略 in / not in 运算符 等同于列表的in运算符,用于判断一个元素是否存在于集合中.如果存在则返回True,否则返回False not in 与in相反 if 2 in {1, 2, 3}: ​ print(“2在{1,2,3}内”) 用于集合的函数: len(x) / max(x) / min(x) sum(x) / any(x) / all(x) 练习: 经理有: 曹操,刘备,孙权 技术员有: 曹操,孙权,张飞,关羽 用集合求: ​ 1. 即是经理也是技术员的人有谁? ​ 2. 是经理,但不是技术员的人有谁? ​ 3. 是技术员,但不是经理的人有谁? ​ 4. 张飞是经理吗? ​ 5. 身兼一职的人有谁? ​ 6. 经理和技术员共有几个人? 1234567891011121314151617manager = &#123;&apos;曹操&apos;, &apos;刘备&apos;, &apos;孙权&apos;&#125;techs = &#123;&apos;曹操&apos;, &apos;孙权&apos;, &apos;张飞&apos;, &apos;关羽&apos;&#125;print(&quot;即是经理也是技术员的人有:&quot;, manager &amp; techs)print(&quot;是经理,但不是技术员的人有:&quot;, manager - techs)print(&quot;是技术员,但不是经理的人有:&quot;, techs - manager)if &apos;张飞&apos; in manager: print(&quot;张飞是经理!&quot;)else: print(&quot;张飞不是经理!&quot;)print(&quot;身兼一职的人有:&quot;, manager ^ techs)print(&quot;经理和技术员共有%d个人&quot; % len(manager | techs)) 集合是可迭代对象 s = {1,2,3} for x in s: ​ print(x) L = [x**2 for x in s] 集合推导式 集合推导式是用可迭代对象创建集合的表达式 语法: ​ {表达式 for 变量 in 可迭代对象 [if 真值表达式]} ​ 注: []里的内容代表可省略 示例: ​ s = “ABC” ​ s2 = {x for x in s} # s2={‘A’, ‘B’, ‘C’} ​ L = [1,2,3,4,5,3,4,5,6] ​ s3 = {x ** 2 for x in L} 推导式小结: 三种: ​ 列表推导式 [x for x in L if …] ​ 字典推导式 {x: x**2 for x in L if …} ​ 集合推导式 {x for x in L if …} 固定集合 frozenset 固定集合是不可变的,无序的,含有唯一元素的集合 作用: ​ 固定集合可以作为字典的键,也可以作为集合的值 固定集合的构造函数: frozenset() 创建一个空的固定集合对象 frozenset(iterable) 用可迭代对象创建一个固定集合对象 示例: fs = frozenset() # 创建空固定集合 fs = frozenset(“ABCCBA”) # fs = frozenset({‘B’, ‘A’, ‘C’}) fs = frozenset(range(10)) fs = frozenset({1, 2, 3}) s = {frozenset({1, 2, 3}), 100, 200} 固定集合的运算: &amp; 交集 | 并集 - 补集 ^ 对称补集 &lt; &lt;= &gt; &gt;= == != in / not in 运算 (以上运算符用法与 set 相同) 固定集合的方法: 相当于集合的全部方法去掉修改集合的方法 详见: ​ help(frozenset)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 元组]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[元组 tuple 元组是不可变的序列，同list一样，元组可以存放任意类型的数据 表示方式: 用小括号()括起来,单个元素括起来后加逗号(,) 区分单个对象还是元组 创建空元组的字面值: t = () # 空元组 创建非空元组的字面值表示 t = 200, # 含有一个元素的元组 t = (20,) # 含有一个元素的元组 t = (1, 2, 3) t = 100, 200, 300 type(x) 函数返回一个对象的类型 元组的错误示例: t = (20) # t绑定整数20 x, y, z = 100, 200, 300 # 序列赋值,不是元组 x, y, z = (100, 200, 300) x, y, z = [100, 200, 300] x, y, z = “ABC” 元组的构造函数 tuple() 创建空元组 等同于() tuple(iterable) 用可迭代对象生成一个元组 示例: t = tuple() # 空元组 t = tuple(range(1, 10, 3)) t = tuple(“ABC”) t = tuple([1,2,3]) 元组的运算： + += = &lt; &lt;= &gt; &gt;= == != in / not in 索引／切片 示例: t = (1, ‘二’, ‘three’) + (4.5, True, None) t = (1,2,3) * 2 t *= 3 比较运算: 规则等同于列表的比较规则 (1, 3, 2) &gt; (1, 2, 3) # True (1, 2, 3) &gt; (1, 2) # True (1, ‘二’) &gt; (‘二’, 1) # TypeError (1, ‘二’) != (‘二’, 1) # True in / not in 运算符 同列表的in运算符相同，用于检查一个值是否存在元组中，如果存在返回True,否则返回False not in 与 in 返回值相反 如: ​ 2 in (1, 2, 3) # True ​ 100 in (1, 2, 3) # False ​ “abc” not in (1,2,3) # True 索引和切片操作: 用法等同于列表的索引和切片操作 元组不支持索引和切片赋值操作 如: ​ t = (1, 2, 3, 4) ​ print(t[2]) # 3 len(x) / max(x) / min(x) sum(x) / any(x) / all(x) 序列的构造函数 str([obj]) list([iterable]) tuple([iterable]) 反转函数: reversed(iterable) 返回反向顺序的可迭代对象 如: ​ for x in reversed(“ABC”): ​ print(x) # 打印 C B A]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 字典]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典 dict 什么是字典 字典是一种可变的容器,可以存储任意类型的数据 字典中的每个数据都是用”键”(key) 进行索引，而不像序列(字符串,列表,元组)可以用索引下标进行索引 字典中的数据没有先后关系,字典的存储是无序的 字典中的数据以键(key)-值(value) 对形式进行映射存储 字典的键不能重复,且只能用不可变类型作为字典的键 字典的表示方式是以{} 括起来,以冒号(:) 分隔键值对,各键值对之间用逗号分隔开 创建空字典的字面值: d = {} # 空字典 创建非空字典字面值: d = {‘name’: ‘tarena’, ‘age’: 15} d = {100: ‘一百’} d = {‘a’: tuple(‘abc’)} # 值为元组 d = {True: “真值”} d = {(1970, 1, 1): ‘计算机元年’} 字典的值可以是任意类型. 字典的键只能是不可变类型 不可变类型: ​ bool, int, float, complex, str, tuple, frozenset(固定集合), bytes(字节串) 可变的类型: ​ list, dict, set(集合), bytearray(字节数组) 字典的构造函数 dict dict() 生成一个空字典 等同于{} dict(iterable) 用可迭代对象初始化一个字典 dict(**kwargs) 用关键字传参形式生成一个字典 示例: ​ d = dict() ​ d = dict([(‘name’, ‘tarena’), (‘age’, 15)]) # 可迭代对象提供的数据必须是有两个元素的序列 ​ d = dict(name=’tarena’, age=15) 字典的基本操作 字典的键索引 ​ 语法: ​ 字典[键] ​ 作用: ​ 用[] 运算符进行取值操作 ​ 示例: ​ d = {‘name’: ‘tarena’, ‘age’:16} ​ print(d[‘name’], ‘今年’, ​ d[‘age’],’岁’) 添加和修改字典元素 ​ 语法: ​ 字典[键] = 值 ​ 说明: ​ 键不存在,创建键并绑定键对应的值 ​ 键存在,修改键绑定的值 ​ 示例: ​ d = {} ​ d[‘name’] = ‘tarena’ # 创建新键值对 ​ d[‘age’] = 15 # 创建新键值对 ​ d[‘age’] = 16 # 修改age键绑定的值 练习: 创建一个字典: ​ d = {‘name’: ‘tarena’, ‘age’:15} ​ 为此字典添加地址(address)键,对应的值为”北京市海淀区”,如果如下: ​ d = {‘name’: ‘tarena’, ‘age’:15, ‘address’: “北京市海淀区”} 123456789101112d = &#123;&apos;name&apos;: &apos;tarena&apos;, &apos;age&apos;:15&#125; # 字面值d = dict(name=&apos;tarena&apos;, age=15)#关键字传参d = dict( ([&apos;name&apos;, &apos;tarena&apos;], (&apos;age&apos;, 15)) ) # 用可迭代对象创建字典d = &#123;&#125;d[&apos;name&apos;] = &apos;tarena&apos;d[&apos;age&apos;] = 15print(&apos;d=&apos;, d)d[&apos;address&apos;] = &apos;北京市海淀区&apos;print(&apos;d=&apos;, d) 删除字典键值对 del 语句 语法: ​ del 字典[键] 示例: ​ d = {‘name’: ‘tarena’, ‘age’: 30} ​ del d[‘name’] # 删除键’name’ 字典的 in / not in运算符 可以用in 运算符来判断一个键是否存在于字典中,如果存在则返回True,否则返回False not in 与 in 返回值相反 示例: ​ d = {‘a’: 100, 200: “二百”} ​ ‘a’ in d # 返回True ​ 200 in d # True ​ 100 in d # False ​ 100 not in d # True 写程序,实在现以要求: 将如下数据形成一个字典seasons: ​ 键 值 ​ 1 —-&gt; ‘春季有1,2,3月’ ​ 2 —-&gt; ‘夏季有4,5,6月’ ​ 3 —-&gt; ‘秋季有7,8,9月’ ​ 4 —-&gt; ‘冬季有10,11,12月’ 1234567891011121314# seasons = &#123;&#125;# seasons[1] = &apos;春季有1,2,3月&apos;# seasons[2] = &apos;夏季有4,5,6月&apos;# seasons[3] = &apos;秋季有7,8,9月&apos;# seasons[4] = &apos;冬季有10,11,12月&apos;seasons = &#123; 1: &apos;春季有1,2,3月&apos;, 2: &apos;夏季有4,5,6月&apos;, 3: &apos;秋季有7,8,9月&apos;, 4: &apos;冬季有10,11,12月&apos;&#125;print(seasons) 让用户输入一个整数,代表季度,打印这个季度的信息,如果用户输入的信息不存在于字典内,则打印”信息不存在” 12345n = int(input(&quot;请输入一个整数: &quot;))if n in seasons: print(seasons[n])else: # n not in seasons print(&quot;信息不存在&quot;) 字典的迭代访问: 字典是可迭代对象,字典只能对键进行迭代访问 示例: ​ d = {‘name’: ‘tarena’, (2002,1,1): “生日”} ​ for k in d: # k用来绑定字典的键 ​ print(k, ‘对应的值是:’, d[k]) 可以用于字典的内建函数 len(x) 返回字典的键值对的个数 max(x) 返回字典键的最大值 min(x) 返回字典键的最小值 sum(x) 返回字典中所有键的和 any(x) 真值测试,如果字典中其中一个键为真值则返回True all(x) 真值测试,如果字典中全部键为真值才返回True 示例: ​ d = {0: ‘零’, 5:’伍’, 8:’捌’, 3:’叁’} ​ len(d) # 4 ​ max(d) # 8 ​ min(d) # 0 ​ sum(d) # 16 ​ any(d) # True ​ all(d) # False 示例: ​ d1 = {1: “One”, 2: “Two”} ​ d2 = {2: “二”, 3:’三’} ​ d1.update(d2) ​ # 合并后 d1 = {1: ‘One’, 2: ‘二’, 3: ‘三’} ​ d = {0: ‘零’, 5:’伍’, 8:’捌’, 3:’叁’} ​ for k in d.keys(): ​ print(k) # 0 5 8 3 ​ for v in d.values(): ​ print(v) # 零 伍 捌 叁 ​ for t in d.items(): # t 绑定元组 ​ print(t) # (0,’零’) (5,’伍’) ​ ​ for k, v in d.items(): ​ print(k,’的值是’, v) 练习: 输入一段字符串,打印出这个字符串中出现过的字符及出现过的次数 如: ​ 输入:ABCDABCABA 打印: ​ a: 4次 ​ b: 3次 ​ d: 1次 ​ c: 2次 123456789# 先将字符串去重,放入到列表L中L = [] # 用来存放出现过的字符for ch in s: # 如果ch没有在L中,说明第一次出现,放到的L中 if ch not in L: L.append(ch)# print(L)for ch in L: print(ch, &quot;:&quot;, s.count(ch), &apos;次&apos;) 字典推导式 字典推导式是用可迭代对象依次生成字典内元素的表达式 语法: ​ {键表达式: 值表达式 for 变量 in 可迭代对象 [if 真值表达式]} ​ 注: [] 的内容代表可省略 示例: ​ # 生成一个字典,键为数字1~9,值为键的平方 ​ d = {x: x**2 for x in range(1, 10)} ​ {1:1, 2:4, 3:9, ….} ​ 有如下字符串: ​ L = [‘tarena’, ‘xiaozhang’, ‘hello’] ​ # 要生成键为单词,值为单词长度的字典: ​ {‘tarena’: 6, ‘xiaozhang’: 9, ‘hello’: 5} ​ d = {s: len(s) for s in L} 字典 vs 列表 都是可变的容器 索引方式不同,列表用整数索引,字典用键索引 字典的插入,删除,修改的速度可能会快于列表(重要) 列表的存储是有序的,字典的存储是无序的 练习: 1.已知有两个等长的列表 ​ list1 = [1001, 1002, 1003, 1004] ​ list2 = [“Tom”, “Jerry”, “Spike”, “Tyke”] ​ 写程序生成如下字典: ​ {“Tom”: 1001, “Jerry”:1002, “Spike”:1003, “Tyke”: 1004} 1234567891011list1 = [1001, 1002, 1003, 1004]list2 = [&quot;Tom&quot;, &quot;Jerry&quot;, &quot;Spike&quot;, &quot;Tyke&quot;]# d = &#123;&#125;# for i in range(len(list1)):# d[list2[i]] = list1[i]d = &#123;list2[i]: list1[i] for i in range(len(list1))&#125;print(d)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 列表]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[列表的定义: 列表是一种容器 列表是可以被改变的序列 列表是由一系列特定元素组成的,元素与元素之间可能没有任何的关联关系,但他们之间有先后顺序关系 创建空列表的字面值: [] # 创建空列表的表达式 创建非空列表的字面值: L = [1, 2, 3, 4] L = [‘北京’, ‘上海’, ‘深圳’] L = [1, ‘Two’, 3.14, ‘四’] L = [1, 2, [3.1, 3.2], 4] 列表的构造(创建) 函数 list list() # 生成一个空的列表 等同于 [] list(iterable) 用可迭代对象创建一个列表 示例: ​ L = list() # L 绑定空列表 [] ​ L = list(“hello”) # L绑定[‘h’,’e’,’l’,’l’,’o’] ​ L = list(range(7, 10)) # L =[7,8,9] 列表的运算: 算术运算: ​ + += = + 用于拼接列表 ​ lx = [1, 2, 3] ​ ly = [4, 5, 6] ​ lz = lx + ly # lz = [1,2,3,4,5,6] += 用原列表与右侧列表拼接,再用变量绑定列表 ​ 语法: ​ L += 可迭代对象 ​ 示例: ​ L = [1, 2, 3] ​ L += [4, 5, 6] # L=[1,2,3,4,5,6] ​ L += “ABC” # L=[1,2,3,4,5,6,’A’,’B’,’C’] ​ L += range(10, 15) * 用于生成重复的列表 x = [1, 2] * 3 # x=[1,2,1,2,1,2] *= 用原列表生成重复列表,并用变量绑定生成的列表 ​ x = [1,2] ​ x *= 3 # x = [1,2,1,2,1,2] 列表的比较运算 运算符: ​ &lt; &lt;= &gt; &gt;= == != 说明: ​ 列表的比较规则与字符串的比较规则相同 ​ 列表要求每两个元素能依次进行比较,否则会出现类型错误 示例: ​ x = [1, 2, 3] ​ y = [1, 3, 2] ​ x &lt; y # True ​ x != y # True ​ [1, ‘Two’] &gt; [‘Two’, 1] # TypeError ​ [1, “Two”, 3.14] &lt; [1, “二”, 5.6] # True 列表是可迭代对象 L = [1, 3, 5, 7] for x in L: ​ print(x) # 1 3 5 7 列表的in / not in 运算符 判断一个值是否存在于列表中,如果存在返回True,否则返回False 说明: ​ 同字符串的in/not in类似,但只能判断单个元素是否存在于列表中 示例: ​ x = [1, ‘Two’, 3, “Four”] ​ 3 in x # True ​ “3” in x # False ​ 4 not in x # True 列表的索引操作: 语法: ​ 列表[整数表达式] 用法: ​ 等同于字符串的索引 ​ 索引分为正向索引和反向索引,规则写字符串规则完全相同 示例: ​ x = [1, “二”, 3, “Four”] ​ print(x[0]) # 1 ​ print(x[1]) # 二 ​ print(x[-1]) # Four 列表的索引赋值操作: 列表是可变的序列,可以通过索引赋值改变列表中的元素 语法: ​ 列表[整数表达式] = 表达式 示例: ​ x = [1, “二”, 3, “Four”] ​ x[1] = 2 # 将列表的第二个元素改为2 ​ x[-1] = 4 ​ print(x) # [1, 2, 3, 4] 列表的切片: 语法: ​ 列表[(开始索引b):(结束索引e)(: (步长s))] 说明: ​ 列表切片取值返回一个列表,规则等同于字符串规则 示例: ​ x = [0, 1, 2, 3, 4, 5, 6, 7, 8] ​ y = x[1:9:2] # 奇数 切片的赋值操作 作用: ​ 可以改变原列表的排序,可以插入和修改数据 ​ 可以用切片改变列表对应的元素的值 语法: ​ 列表[切片] = 可迭代对象 注: 赋值运算符的右侧必须是一个可迭代对象 示例: ​ L = [2.2, 3.3, 4.4] ​ L[0:1] = [1, 2] # L = [1,2,3.3,4.4] ​ L[2:] = [3, 4, 5] # L = [1,2,3,4,5] ​ L[::] = [30, 40] # L = [30, 40] ​ L[0:0] = [10, 20] # L =[10,20,30,40] ​ L = [3, 4] ​ L[1:1] = [3.1, 3.2] #L=[3,3.1,3.2,4] ​ L =[3, 4] ​ L[2:2] = [5,6,7] # L=[3,4,5,6,7] ​ L = [3, 5] ​ L[1:1] = “AB” # L=[3, ‘A’, ‘B’, 5] ​ L = [3, 5, 10] ​ L[1:2] = range(4, 10) 切片注意事项: 对于步长不等于1的切片赋值,赋值运算符的右侧的可迭代对象提供的元素个数一定要等于切片切出的段数 如: ​ L = [1, 2, 3, 4, 5, 6] ​ L[::2] = “ABC” # 对的 ​ L[::2] = “ABCD” # 错的 列表 向列表内添加数据 ​ L[0:0] = [100, 200] 修改数据: ​ L[1] = 300 ​ L[1:5] = [1,2,3] 删除数据: ​ L[1:5] = [] del 语句 用于删除列表的元素 示例: ​ del L[2] # 删除单个元素 ​ del L[::2] # 删除切片切出来的部分 练习: 已知有列表: ​ L = [3, 5] ​ 用索引的切片等操作,将原列表的改变为: ​ L = [1, 2, 3, 4, 5, 6] ​ 将列表反转(先后顺序颠倒),删除最后一个元素后,打印此列表: ​ print(L) # [6, 5, 4, 3, 2] 1234567891011L = [3, 5]# print(id(L))L[1:1] = [4]L[0:0] = [1, 2]L[len(L):len(L)] = [6]print(L) # L = [1, 2, 3, 4, 5, 6]# 将列表反转(先后顺序颠倒),删除最后一个元素后,打印此列表:L[::] = L[::-1] # 新建的列表,重新赋值给Ldel L[-1]print(L) # [6, 5, 4, 3, 2] ​ 练习: 输入三个数,存于列表中,打印出这三个数的最大值,最小值和平均值 12345678a = int(input(&quot;请输入第1个数: &quot;))b = int(input(&quot;请输入第2个数: &quot;))c = int(input(&quot;请输入第3个数: &quot;))L = [a, b, c]print(&quot;最大值是:&quot;, max(L))print(&quot;最小值是:&quot;, min(L))print(&quot;平均值是:&quot;, sum(L)/len(L)) 写程序,让用户循环输入一些整数,当输入 -1时结束输入,将这些整数存于列表L中 ​ 1) 打印您共输入了几个有效的数 ​ 2) 打印您输入的数的最大值是多少? ​ 3) 打印您输入的数的平均值是多少? 12345678910111213141516L = [] # 先创建一个列表,用L绑定,装备存放数据while True: n = int(input(&quot;请输入不等于-1的整数: &quot;)) if -1 == n: break # 将n放到的L绑定的列表中 # 放入到列表的末尾: L += [n] # L[len(L):len(L)] = [n]# print(L)# 1) 打印您共输入了几个有效的数print(&quot;您共输入了%d个数&quot; % len(L))# 2) 打印您输入的数的最大值是多少?print(&quot;最大值是:&quot;, max(L))# 3) 打印您输入的数的平均值是多少?print(&quot;平均值是:&quot;, sum(L)/len(L)) 深拷贝和浅拷贝 浅拷贝 shallow copy ​ 浅拷贝是指在对象复制过程中,只复制一层变量,不会复制深层变量绑定的对象的复制过程 如: ​ L = [3.1, 3.2] ​ L1 = [1, 2, L] ​ L2 = L1.copy() # 浅拷贝 ​ print(L1) # [1, 2, [3.1, 3.2]] ​ print(L2) # [1, 2, [3.1, 3.2]] ​ L[0] = 3.14 # L2[2][0] = 3.14 ​ print(L1) # [1, 2, [3.14, 3.2]] ​ print(L2) # [1, 2, [3.14, 3.2]] ​ print(L) # [3.14, 3.2] 深拷贝 deep copy: ​ import copy # 导入复制模块 ​ L = [3.1, 3.2] ​ L1 = [1, 2, L] ​ L2 = copy.deepcopy(L1) # 深拷贝 ​ print(L1) # [1, 2, [3.1, 3.2]] ​ print(L2) # [1, 2, [3.1, 3.2]] ​ L2[2][0] = 3.14 ​ print(L1) # [1, 2, [3.1, 3.2]] ​ print(L2) # [1, 2, [3.14, 3.2]] ​ print(L) # [3.1, 3.2] 列表与字符串比较: 都是序列,元素之间有先后顺序关系 字符串是不可变的序列,列表是可变的序列 字符串中每个元素只能存储字符(编码),而列表可以存储任意类型的元素 列表和字符串都是可迭代对象 列表推导式 list comprehension 列表推导式是用可迭代对象创建列表的表达式 作用: ​ 用简易方法生成列表 语法: ​ [表达式 for 变量 in 可迭代对象] ​ 或 ​ [表达式 for 变量 in 可迭代对象 if 真值表达式] 示例: ​ # 以下生成一个数值为1~9的平方的列表 ​ # [1, 4, 9, 16, 25, …… 81] ​ L = [] ​ for x in range(1, 10): ​ L.append(x**2) ​ # 用列表推导式: ​ L = [x**2 for x in range(1, 10)] 练习: 用列表推导式生成 1 ~ 100内所有奇数的平方的列表 [1, 9, 25, ….. ] 1L = [x**2 for x in range(1, 100, 2)] 示例: ​ # 以下生成一个数值为1~9的平方的列表(只保留偶数) ​ [4, 16, 36 …] ​ L = [x**2 for x in range(1, 10) if x % 2 == 0] ​ 练习: 写程序.输入一个开始的整数值用begin绑定 ​ 输入一个结束的整数用end绑定 ​ 将从begin开始到end结束(不包含end)的所有偶数存于列表中,并打印(建议用列表推导式完成) 123456begin = int(input(&quot;请输入开始值: &quot;))end = int(input(&quot;请输入结束值: &quot;))L = [x for x in range(begin, end) if x % 2 == 0]print(L) 写程序,让用户输入很多个整数(包含正整数和负整数) 保存于列表L 中. 输入0结束输入. 然后把列表L中的所有正数存于列表L1 中,把列表L中的所有负数存于列表L2中 打印原列表L和 正数列表L1 和负数列表L2 123456789101112L = []while True: x = int(input(&quot;请输入整数(0结束): &quot;)) if x == 0: break L.append(x)L1 = [x for x in L if x &gt; 0] # 正数L2 = [x for x in L if x &lt; 0] # 负数print(&quot;原列表是:&quot;, L)print(&quot;正数的列表L1=&quot;, L1)print(&quot;负数的列表L2=&quot;, L2) ##### 列表推导式的嵌套: [表达式1 for 变量1 in 可迭代对象1 if 真值表达式1 ​ for 变量2 in 可迭代对象2 if 真值表达式2 ​ … ] 示例: ​ 将列表[10, 20, 30] 中的元素与列表[1,2,3]元素分别相加,将得到的元素放于一个列表中 ​ L = [x+y for x in [10, 20, 30] for y in [1, 2, 3]] 练习: 用字符串”ABC” 和 “123” 生成如下列表: ​ [‘A1’, ‘A2’, ‘A3’, ‘B1’, ‘B2’, ‘B3’, ‘C1’, ‘C2’, ‘C3’] 1[x + y for x in &quot;ABC&quot; for y in &quot;123&quot;] 已知有一个字符串: ​ s= ‘100,200,300,500,800’ ​ 将其转化为数字组成的列表,列表内部为整数: ​ L = [100,200,300,500,800] 用列表推导式生成如下列表: ​ L = [1, 4, 7, 10, …. 100] 1L = [x for x in range(1, 101, 3)] 用例表推导式生成如下列表(思考题) ​ [[1,2,3], [4,5,6], [7,8,9]] 答案: ​ # 方法1 ​ [[x, x+1, x+2] for x in range(1,8,3)] ​ # 方法2 ​ [[y for y in range(x, x + 3)] ​ for x in range(1,8,3)] ​ # 改为for语句 ​ L = [] ​ for x in range(1, 8, 3): ​ temp = [] ​ for y in range(x, x + 3): ​ temp.append(y) ​ L.append(temp) 练习: 有一些数存于列表中.如: ​ L = [1, 3, 2, 1, 6, 4, 2, …. 98,82] ​ 1) 将列表L中出现的数字存入到另一个列表L2中 ​ 要求: ​ 重复出现多次的数字只在L2中保留一份(去重) ​ 2) 将列表中出现两次的数字存于列表L3中，在L3中只保留一份 123456789101112131415161718L = [1, 3, 2, 1, 6, 4, 2, 6, 6, 98, 82]# 1) 将列表L中出现的数字存入到另一个列表L2中L2 = [] # 准备存放出现过的数字for x in L: # 将所有数遍历一遍 # 如果是第一次出现,则添加到L2列表中 if x not in L2: L2.append(x)print(&quot;L2 =&quot;, L2)# 2) 将列表中出现两次的数字存于列表L3中，在L3中只保留一份L3 = []for x in L: # 第一次出现,同时在L中出现两次,则加入到L3中 if x not in L3 and L.count(x) == 2: L3.append(x)print(&quot;L3=&quot;, L3) 计算出100以内的全部素数，将这些素数存于列表中，然后打印出列表中的这些素数 12345678910111213141516L = [] # 此容器准备加入素数for x in range(1, 101): # 如果x是素数,则把x加入到L中,否则跳过 isprime = True # 先假设x是素数 # 如果x不是素数,就把isprime置为False if x &lt; 2: isprime = False else: for i in range(2, x): if x % i == 0: # 整除不是素数 isprime = False break if isprime: # 一定为素数 L.append(x)print(&quot;L = &quot;, L) 生成前40 个斐波那契(Fibonacci)数列中的数 ​ 1 1 2 3 5 8 13 21 ​ 要求: 将这些数保存于列表中．打印这些数 123456789101112131415161718192021222324252627# 方法1# L = [] # 空列表,准备放入算出来的斐波那契数# a = 0 # a 代表当前一个数的前一个数# b = 1 # b代表当前的斐波那契数# while len(L) &lt; 40:# # 当列表长度不够40就算出一个数,加入到L中# # 每次循环算出一个数,加入到列表L中# L.append(b) # 已经有的数放入列表# c = a + b # 求出下一个斐波那契数# a = b# b = c# 方法2# L = [] # 空列表,准备放入算出来的斐波那契数# a = 0 # a 代表当前一个数的前一个数# b = 1 # b代表当前的斐波那契数# while len(L) &lt; 40:# # 当列表长度不够40就算出一个数,加入到L中# # 每次循环算出一个数,加入到列表L中# L.append(b) # 已经有的数放入列表# a, b = b, a + b # 序列赋值# 方法3L = [1, 1]while len(L) &lt; 40: L.append(L[-1] + L[-2])print(L)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 字符串]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串 str 作用: ​ 用来记录文本(文字)信息 字符串的表示方法: ​ 在非注释中,凡是用引号括起来的部分都是字符串 ​ ‘ 单引号 ​ “ 双引号 ​ ‘’’ 三单引号 ​ “”” 三双引号 空字符串的字面值表示方法: ​ ‘’ ​ “” ​ ‘’’’’’ ​ “””””” ​ 注: 空字符串的布尔值为False 非空字符串的字面值表示方法: ​ ‘hello’ ​ “hello” ​ ‘’’hello’’’ ​ “””hello””” 单引号和双引号的区别: ​ 单引号内的双引号不算结束符 ​ 双引号内的单引号不算结束符 示例: ​ print(“I’m teacher”) ​ print(‘my name is “weimingze”‘) 三引号字符串 用’’’或”””括起来的内容为三引号字符串 作用: ​ 三引号字符串中的换行会自动转换为换行符’\n’ ​ 三引号内可以包含单引号和双引号 示例: ​ print(‘welcome to beijing.\nI like python!\n I am Studing…’) ​ # 用三引号写为: ​ print(‘’’welcome to beijing. ​ I like python! ​ I am Studing”””) 隐式字符串字面值拼接 示例: ​ s = “I’m “ ‘“weimingze”‘ ‘这是三双引”””‘ “这是三单引’’’” ​ print(s) 用转义序列代表特殊字符 字符串字面值中用字符反斜杠() 后跟一些字符代表特一个字符 ​ 转义格式 含义 ​ \’ 代表一个单引号 ​ \” 代表一个双引号 ​ \n 代表一个换行符 ​ \ 一个反斜杠 ​ \r 返回光标至行首字符 ​ \t 水平制表符 ​ \v 垂直制表符 ​ \b 倒退字符(backspace) ​ \f 换页 ​ \0 空字符(字符值为零) ​ \0oo oo为两位八进制表示的字符 ​ \xXX XX为两位十六进制表示的字符 ​ \uXXXX XXXX为四位十六进制表示的Unicode 16字符 ​ \UXXXXXXXX Unicode32 的十六进制表示的字符 ascii 编码 $ man ascii # 查看所有英文字符的编码 常用的ASCII编码: 字符 十进制 十六进制 ‘0’ 48 0x30 ‘A’ 65 0x41 ‘a’ 97 0x61 求字符串长度的函数: len(s) 返回字符串的字符的个数 练习: 求以下字符串有几个字符 ​ ‘1234abcd’ # 8 ​ ‘5\’4”‘ # 4 ​ ‘\”A\x34\056’ # 4 ​ ‘\r\n\t\z’ # 5 raw 字符串(原始字符串) 格式: ​ r’字符串内容’ ​ r”字符串内容” ​ r’’’字符串内容’’’ ​ r”””字符串内容””” 作用: ​ 让转义字符 \ 无效 示例: s1 = ‘C:\newfile\test.py’ print(s1) s2 = r’C:\newfile\test.py’ print(s2) 字符串的运算 运算符:​ + += = + 加号用于拼接字符串 += 用于原字符串与右侧字符串拼接后替换原变量 示例: ​ s = “abcd” + “123” # s = ‘abcd123’ ​ s += “ABCD” # s =’abcd123ABCD’ * 运算符生成重复的字符串 x = “ABCD” * 3 # x = ‘ABCDABCDABCD’ 注: 字符串只能和整数相乘 x = “123” x *= 2 # x= ‘123123’ 字符串的比较运算: 运算符: ​ &lt; &lt;= &gt; &gt;= == != 规则: ​ 依次按编码值进行比较,一旦不同,比较将结束 ​ 当编码值与长度完全相同时两个字符串相等 示例: ​ ‘A’ &lt; ‘B’ # True ​ ‘ABC’ &gt; ‘ABB’ # True ​ ‘ABC’ &lt; ‘ACB’ # True ​ ‘ABC’ &gt; ‘abc’ # False ​ ‘AB’ &lt; ‘ABC’ # True ​ ‘ABC’ != ‘CBA’ # True ​ ‘AD’ &gt; ‘ABCD’ # True in / not in 运算符 作用: ​ in 用于序列,字典,集合中,用于判断某个值是否存在于容器中,如果存在返回True,否则返回False ​ not in 写 in的返回结果相反 格式: ​ 对象 in 序列 示例: ​ x = ‘welcome to tarena’ ​ ‘to’ in x # True ​ ‘beijing’ in x # False ​ ‘123’ not in x # True 索引运算 index python 字符串是不可以改变的字符序列 语法: ​ 字符串[整数表达式] 说明: ​ 1. python序列都可以用索引(index) 来访问序列中的对象 ​ 2. python 序列正向索引是从0开始的,第二个索引为1, …, 最后一个索引为len(s)-1 ​ 3. python序列的反向索引是从-1 开始的,-1代表最后一个,-2 代表倒数第二个,…, 第一个是-len(s) 示例: ​ s = ‘ABCDE’ ​ print(s[1]) # B ​ print(s[4]) # E ​ print(s[-1]) # E ​ print(s[-5]) # A ​ print(s[-6]) # IndexError 索引错误 练习: 输入一个字符串,打印如下内容: ​ 1) 打印这个字符串的第1个字符 ​ 2) 打印这个字符串的最后一个字符 ​ 3) 如果这个字符串的长度是奇数,打印中间这个字符 ​ 注: ​ 求字符串长度的函数是 len(s) 12345678s = input(&quot;请输入字符串: &quot;) # &quot;ABCDEFG&quot;print(&quot;第一个字符是:&quot;, s[0])print(&quot;最后一个字符是:&quot;, s[-1])if len(s) % 2 == 1: # center_index = len(s) // 2 # print(&quot;中间字符是:&quot;, s[center_index]) print(&quot;中间字符是:&quot;, s[len(s) // 2]) 字符串切片操作 slice 从字符串序列中取出相应的元素,重新组成一个新的字符串序列 语法: ​ 字符串[(开始索引b):(结束索引e)(:(步长s))] ​ 注: 小括号() 括起来的部分代表可省略 说明: ​ 1. 开始索引是切片开始切下的位置,0代表第一个元素…,-1代表最后一个索引(与索引规则相同) ​ 2. 结束索引是切片的终止索引(但不包含终止点) ​ 3. 步长是切片每次获取完当前元素后移动的方向和偏移量 ​ 1) 没有步长,相当于步长为1(默认) ​ 2) 当步长为正数时,取正向切片,开始索引默认为0,结束索引默认为最后一个元素的下一个位置 ​ 3) 当步长为负数时,取反向切片,默认起始位置是最后一个元素,终止位置是第一个元素的前一个位置 示例: ​ s = “ABCDE” ​ a = s[1:4] # a = ‘BCD’ ​ a = s[1:] # a = ‘BCDE’ ​ a = s[:4] # a = ‘ABCD’ ​ a = s[:] # a = ‘ABCDE’ ​ a = s[2:2] # a = ‘’ 空字符串 ​ a = s[0:5:2] # a = ‘ACE’ ​ a = s[::-1] # a = ‘EDCBA’ ​ a = s[::-2] # a = ‘ECA’ ​ a = s[3:0:-1] # a = ‘DCB’ ​ a = s[3:0:-2] # a = ‘DB’ 练习: 1.写一个程序,输入一个字符串,把字符串的第一个字符和最后一个字符去掉后,打印出处理后的字符串 123s = input(&quot;请输入一个字符串: &quot;)s2 = s[1:-1]print(&quot;处理后的字符串是:&quot;, s2) 写一个程序,输入任意一个字符串,判断这个字 符串是否是回文 ​ (回文是指中心对称的文字) ​ 如: ​ 上海自来水来自海上 ​ ABCCBA ​ 12321 123456s = input(&quot;请输入文字: &quot;)s2 = s[::-1] # 反转字符串if s == s2: print(s, &apos;是回文&apos;)else: print(s, &apos;不是回文&apos;) python运算符的优先级: 见文档: ​ python_base_docs_html/python运算符优先级.html python3 中常用的序列函数 len(x) 返回序列的长度 max(x) 返回序列的最大值元素 min(x) 返回序列的最小值元素 示例: ​ s = “hello” ​ print(len(s)) # 5 ​ print(max(s)) # o ​ print(min(s)) # e 字符编码转换函数 ord(c) 返回一个字符c的Unicode编码值 chr(i) 返回i这个值所对应的字符 示例: ​ c = ord(‘A’) ​ print(c) # 65 ​ ch = chr(c) # ch=’A’ ​ print(ch) # A 整数转字符串函数: bin(i) 将整数转为二进制字符串 oct(i) 将整数转为八进制字符串 hex(i) 将整数转为十六进制字符串 示例: ​ a = 13 ​ print(bin(a)) # 0b1101 ​ print(oct(a)) # 0o15 ​ print(hex(a)) # 0xd 字符串构造函数 str(obj=’’) 将对象转换为字符串 示例: ​ “123” + 1 # 报错 ​ “123” + str(1) # 1231 python3中常用的字符串方法(method) 方法的调用语法: 对象.方法名(方法传参) 示例: ​ ‘abc’.isalpha() # 对的 ​ 123.isalpha() # 错的 练习: 输入一个字符串,把输入的字符串中的空格全部去掉(包括字符串中间的空格) ​ 1) 打印原字符串及长度 ​ 2) 打印处理后的字符串及长度 1234567s = input(&apos;请输入字符串: &apos;)# 1) 打印原字符串及长度print(s,&apos;的长度是:&apos;, len(s))s2 = s.replace(&apos; &apos;, &apos;&apos;)# 2) 打印处理后的字符串及长度print(s2, &apos;的长度是:&apos;, len(s2)) 写程序,输入三行文字,让这三行文字在一个方框内居中显示 ​ 如: ​ 请输入: hello! ​ 请输入: I’m studing python! ​ 请输入: I like python! ​ 打印如下: ​ +———————+ ​ | hello! | ​ | I’m studing python! | ​ | I like python! | ​ +———————+ ​ 注: 不要输入中文 123456789101112131415a = input(&quot;请输入第1行: &quot;)b = input(&quot;请输入第2行: &quot;)c = input(&quot;请输入第3行: &quot;)max_len = max(len(a), len(b), len(c))# 打印第一行first_line = &quot;+&quot; + &apos;-&apos; * (max_len + 2) + &apos;+&apos;print(first_line)print(&quot;| &quot; + a.center(max_len) + &apos; |&apos;)print(&quot;| &quot; + b.center(max_len) + &apos; |&apos;)print(&quot;| &quot; + c.center(max_len) + &apos; |&apos;)# 打印最后行print(first_line) 字符串的格式化表达式: 作用: ​ 生成一定格式的字符串 运算符: ​ % 语法格式: ​ 格式字符串 % 参数值 ​ 格式字符串 % (参数值1, 参数值2, …) 说明: ​ 格式字符串中以%开头的字符为占位符，占位符的位置将用参数值替换 示例: ​ fmt = “姓名: %s, 年龄: %d” ​ name = input(‘请输入姓名:’) # xiaoli ​ age = int(input(‘请输入年龄:’)) # 20 ​ s = fmt % (name, age) ​ print(s) #姓名: xiaoli, 年龄: 20 格式化字符串中的占位符和类型码 %s 字符串，使用str(x) 函数转换 %r 字符串，使用repr(x) 函数转换 %c 整数转为单个字符 %d 整数转为十进制整数 %o 整数转为八进制整数 %x 整数转为十六进制整数(字符a-f小写) %X 整数转为十六进制整数(字符A-F大写) %e 指数形浮点数(e小写) 如 2.9e10 %E 指数形浮点数(E大写) 如 2.9E10 %f,%F 浮点数十进制形式 %g,%G 十进制形式或指数形式浮点数自动转换 %% 等同于一个百分号 占位符和类型码之间的格式化语法: 格式: ​ % - + 0 宽度.精度 类型码 说明: ​ - 左对齐(默认是右对齐) ​ + 显示正号 ​ 0 左侧空白位置补零 ​ 宽度: 整个数据输出的宽度 ​ 精度: 保留小数点后多少位(默认6位) 示例: ​ “%10d” % 123 # ‘ 123’ ​ “%-10d” % 123 # ‘123 ‘ ​ “%10s” % ‘abc’ # ‘ abc’ ​ “%-5s” % ‘abc’ # ‘abc ‘ ​ “%-+10d” % 123 # ‘+123 ‘ ​ “%010d” % 123 # ‘0000000123’ ​ “%f” % 12.34567890 # ‘12.345679’ ​ “%.2f” % 12.34567890 # ‘12.35’ ​ “%7.2f” % 12.34567890 # ‘ 12.35’ 字符串文本解析方法split 和join S.split(sep=None) 将字符串,使用sep作用分隔符分割 S字符串,返回分割后的后的字符串列表,当不给定参数时,用空白字符作用分隔符分割 S.join(iterable) 用可迭代对象中的字符口中,返回一个中间用S进行分隔的字符串 示例: ​ s = “Beijing is capital” ​ L = s.split(‘ ‘) # L = [‘Beijing’, ‘is’, ‘capital’] ​ L = [‘aaaa’,’bbbb’,’cccc’] ​ s2 = “#”.join(L) # s2 = “aaaa#bbbb#cccc” 练习: 有字符串 ​ s = “hello” 请生成如下字符串: ​ ‘h e l l o’ 和 ‘h-e-l-l-o’ ‘ ‘.join(s) # ‘h e l l o’ ‘-‘.join(s) # ‘h-e-l-l-o’]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 面试题]]></title>
    <url>%2F2019%2F02%2F09%2Fpython-%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Django之应用]]></title>
    <url>%2F2019%2F01%2F18%2FDjango%E4%B9%8B%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.什么是应用 ​ 应用就是网站中的一个独立的程序模块 ​ 在Django中,主目录一般不处理用户的具体请求,主目录主要做项目的初始化配置以及请求的分发(分布式请求处理),具体的请求是由各个应用去处理的 2.创建应用 ​ 1.manage.py 指令创建 ​ ./manage.py startapp 应用名称 ​ ex: ​ ./manage.py startapp news ​ ​ 2.在 settings.py 中进行注册 ​ 在 INSTALLED_APPS 中追加应用名称即可 ​ INSTALLED_APPS = [ ​ …. …., ​ ‘应用名称’, ​ ] 3.应用的结构组成 ​ 1.migrations 文件夹 ​ 存放数据库的中间文件 ​ 与模型相关 ​ 2.init.py ​ 应用的初始化文件 ​ 3.admin.py ​ 应用的后台管理配置文件 ​ 4.app.py ​ 应用的属性配置文件 ​ 5.models.py ​ 模型的映射文件 ​ 6.tests.py ​ 应用的单元测试文件 ​ 7.views.py ​ 定义视图处理函数的文件 4.分布式的路由系统 (请求地址分发) ​ 在每个应用中创建 urls.py 结构参考主目录的 urls.py 1.路由系统 ​ 改版 ​ 访问路径：localhost:8000/music/index ​ 改版 ： localhost:8000/music ​ 访问 index()视图处理函数 访问路径：localhost:8000/index/index 改版 ：localhost:8000/ 访问 index应用中的index()视图函数 访问路径：localhost:8000/login 访问index应用中的login()视图函数 访问路径：localhost:8000/register 访问index应用中的register()视图函数]]></content>
      <categories>
        <category>Python Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django]]></title>
    <url>%2F2019%2F01%2F18%2FDjango%2F</url>
    <content type="text"><![CDATA[1.什么是Django Django是一个开源框架,2005年发布,采用Python语言编写的 早期主要是做新闻和内容管理的 Django本身提供了非常强大的后台管理系统 版本: 2.1.5 使用: 1.11.8 官网:http://www.djangoproject.com 中文文档:http://djangobook.py3k.cn/2.0/、 2.框架模式 MTV ​ M ：Models ​ T ：Templates ​ V ：Views 3.Django的安装 1.查看已安装的Django版本 ​ 1.进入到终端以及Python交互模式 ​ 交互模式：python3 / ipython3 ​ 2.交互模式中输入：import django ​ 1.如果未报错:当前环境中已经安装django ​ 2.如果报错:没有django ​ 3.查看版本 ​ 交互模式中:django.VERSION 2.安装Django ​ 1.在线安装 ​ pip3 : 安装到python3下 ​ pip : 安装到python2下 ​ sudo pip3 install django ​ (默认安装Django的最新版本) ​ sudo pip3 install django==1.11.8 ​ (指定安装Django的1.11.8) ​ 2.离线安装 ​ 1.下载安装包 ​ 2.sudo pip3 install Django-1.11.8.tar.gz 4.Django框架的使用 1.创建Django项目 ​ 使用 django-admin 创建Django项目 ​ 语法: django-admin startproject 项目名(终端输入) 2.Django项目的结构介绍 ​ 1.manage.py ​ 包含执行django中的各项操作的指令(子命令) ​ 如: ​ 启动服务 : runserver (例：python3 manage.py runserver) ​ 创建应用 :start ​ 创建后台管理员 : ​ …. …. ​ 2.主目录(与项目名称一致的目录) ​ 1.init.py ​ 初始化文件,服务启动时自动运行 ​ 2.urls.py ​ 项目的基础url配置文件(基础的路由配置) ​ 3.wsgi.py ​ Web Server Gateway Interface ​ Web 服务 网关 接口的配置文件 ​ 部署项目时使用 ​ 4.settings.py ​ 项目的主配置文件,启动服务器时自动运行 ​ 1.BASE_DIR : 获取当前项目的绝对路径 ​ 2.DEBUG : 是否启用调试模式 ​ True : 启动调试模式(开发环境中使用) ​ False : 不启用调试(生产环境中使用) ​ 3.ALLOWED_HOSTS ​ 设置允许访问到本项目的地址列表 ​ ①如果为空的话,表示只有本机(127.0.0.1/localhost)才能访问 ​ ②[‘*’],表示任何能够表示该机器的地址都能够访问到当前项目 ​ (127.0.0.1/localhost / 0.0.0.0 / IP地址都可以) ​ 注意： 如果允许在局域网内被其他机器访问的话: ​ 如果允许被其他机器访问的话,启动服务时必须使用以下方式: ​ ./manage.py runserver 0.0.0.0:端口号 ​ 4.INSTALLED_APPS ​ 指定已安装的应用,如果有自定义应用的话,必须要在此注册 ​ 5.MIDDLEWARE ​ 指定中间件信息 ​ 6.TEMPLATES ​ 指定模板配置 ​ 7.DATABASES ​ 指定数据库配置 ​ 8.LANGUAGE_CODE ​ 语言设置,如果需要中文的话,允许更改为 zh-Hans ​ 9.TIME_ZONE ​ 指定时区,如果指定中国时区的话,允许更改为 “Asia/Shanghai” 5.URL的使用 1.urls.py ​ 主路由配置文件,默认在主目录中 ​ 包含最基本的地址映射 ​ 作用:通过urls.py中定义好的地址找到对应的视图处理函数 ​ （在urlpatterns中，通过若干url()来表示具体的路由-视图映射关系） ​ from django.conf.urls import url ​ from django.contrib import admin ​ urlpatterns = [ ​ url(r’^admin/‘,admin.site.urls), ​ ] 2.url() 的语法规范 ​ 作用:匹配用户的访问路径,交给对应的视图处理程序 ​ 语法: ​ from django.conf.urls import url ​ url(regex,views,kwargs=None,name=None) ​ 1.regex : 允许是正则表达式,匹配请求的url ​ 2.views : 对应的视图处理函数名 ​ 3.kwargs : 字典,用来向views传参 ​ 4.name : 为 url 起别名,在地址反向解析时使用 3.通过 url 向视图传参 ​ http://localhost:8000/show/2018 ​ http://localhost:8000/show/2015 ​ http://lcoalhost:8000/show/2017 ​ 1.使用正则表达式传参 ​ 使用正则表达式的子组传参 - (),一个子组就是一个参数,多个参数的话要使用多个子组表示,并且中间使用 / 隔开 ​ # 当访问路径时 /show/四位数字/ 的时候 ​ 在 urls.py 中 ​ url(r’^show/(\d{4})/$’,show1_views), ​ 在views.py中 ​ def show1_views(request,year): ​ pass ​ 2.通过 kwargs 参数传参 ​ dic = { ​ ‘name’:’wangwc’, ​ ‘age’:18 ​ } ​ url(r’^show/$’,show3_views,dic) ​ def show3_views(request,name,age): ​ pass]]></content>
      <categories>
        <category>Python Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX（python）框架]]></title>
    <url>%2F2019%2F01%2F08%2FAJAX%EF%BC%88python%EF%BC%89%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[1.什么是AJAX Asynchronous Javascript And Xml ​ 异步的 JS 和 xml xml : eXtensible Markup Language ​ 早期是做 前后端数据交互格式 ​ 由于结构繁琐,后来就被抛弃了 …,被JSON所取代 AJAX:通过 JS 异步的向服务器发送请求并接受响应数据,响应数据的格式原来是xml,后来变成了JSON 同步请求:当客户端向服务器发送请求时,服务器在处理的过程中,浏览器只能等待,效率较低 异步请求:当客户端向服务器发送请求时,服务器在处理的过程中,浏览器可以做其他的操作,不需要一直等待 AJAX的优点: ​ 1.异步 访问 ​ 2.局部 刷新 AJAX的使用场合:​ 1.搜索建议 ​ 2.表单验证 ​ 3.前后端完全分离时使用 2.AJAX核心对象 - 异步对象(XMLHttpRequest) 1.什么是XMLHttpRequest ​ 简称为 xhr ​ 称为 “异步对象” 代替浏览器向服务器发送异步的请求并接收响应 2.创建异步对象 ​ 主流的异步对象是 XMLHttpRequest 类型的.并且所有主流浏览器(IE7+,Chrome,Firefox,Safari,Opera)也都支持 XMLHttpRequest.但在IE低版本浏览器(IE7以及以下),就不支持XMLHttpRequest,需要使用 ActiveXObject() 来创建异步对象 ​ 如果支持 XMLHttpRequest ​ var xhr = new XMLHttpRequest() ​ 如果不支持 XMLHttpRequest ​ var xhr = new ActiveXObject(“Microsoft.XMLHTTP”) ​ 练习: 根据不同的浏览器创建 xhr 并返回 ​ 1.创建函数 - createXhr() ​ 2.在函数体内,判断浏览器对xhr的支持性,创建不同的xhr,并返回 ​ 3.创建一个按钮,调用createXhr() 得到返回值,并输出在console上 1234567891011121314#run.pyfrom flask import Flask, requestapp = Flask(__name__)@app.route(&apos;/02-server&apos;)def server02_views(): return &quot;这是我的第一个ajax的响应&quot;@app.route(&apos;/03-server&apos;)def server03_views(): #接收前端传递过来的数据 uname=request.args[&apos;uname&apos;] return &quot;欢迎:&quot;+unameif __name__ == &quot;__main__&quot;: app.run(debug=True) 12345678910111213141516171819202122232425262728#01-xhr.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; function createXhr()&#123; var xhr = null; //判断浏览器对xhr的支持性 if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; return xhr; &#125; function testXhr()&#123; var xhr = createXhr(); console.log(xhr); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button onclick=&quot;testXhr()&quot;&gt;创建异步对象&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#02-ajaxget.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt; &lt;a href=&quot;/02-server&quot;&gt;去往/02-server&lt;/a&gt; &lt;/h2&gt; &lt;button onclick=&quot;btnAjax()&quot;&gt;使用AJAX发送请求&lt;/button&gt; &lt;h2 id=&quot;show&quot;&gt;&lt;/h2&gt; &lt;script&gt; function createXhr()&#123; var xhr = null; //判断浏览器对xhr的支持性 if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; return xhr; &#125; function btnAjax()&#123; //1.创建xhr对象 var xhr = createXhr(); //2.创建请求// xhr.open(&apos;get&apos;,&apos;/02-server&apos;,true); xhr.open(&apos;get&apos;,&apos;/03-server?uname=wangwc&apos;,true); //3.设置回调函数 xhr.onreadystatechange=function()&#123; //判断readyState是否为4并且status是否为200 //如果以上条件达成，则可以接收响应数据 if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; //接收响应数据 var resText=xhr.responseText; //将resText放在#show中显示 document.getElementById(&quot;show&quot;).innerHTML=resText; &#125; &#125; //4.发送请求 xhr.send(null); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.xhr 的成员 (重点)​ 1.方法 - open() ​ 作用:创建请求 ​ 语法:open(method,url,async) ​ method:请求方式,取值 ‘get’ 或 ‘post’ ​ url:请求地址,字符串 ​ async:是否采用异步的方式发送请求 ​ true:异步请求 ​ false:同步请求 ​ ex: ​ xhr.open(‘get’,’/server’,true); ​ 2.属性 - readyState ​ 作用:请求状态,通过不同的请求状态值来表示xhr与服务器的交互情况 ​ 由 0-4 共 5 个值表示5个不同的状态 ​ 0 : 请求尚未初始化 ​ 1 : xhr已经与服务器建立连接 ​ 2 : 服务器端已经接收请求 ​ 3 : 请求正在处理中 ​ 4 : 响应已经完成 ​ 3.属性 - status ​ 作用:服务器端的响应状态码 ​ 200 : 表示服务器已经正确处理请求并给出响应 ​ 404 : 请求资源不存在 ​ 500 : 服务器内部错误 ​ 4.属性 - responseText ​ 作用 : 接收服务器端响应回来的数据 ​ 5.事件 - onreadystatechange ​ 作用 : 每当 xhr 的 readyState 值发生改变的时候都要触发的行为操作 - 回调函数 ​ 关注: ​ 1.xhr 的 readyState 是否为 4 ​ 2.xhr 的 status 是否为 200 ​ 如果以上两点同时满足的话,则可以接收响应数据(responseText) ​ ex:为 xhr 绑定 onreadystatechange 事件 ​ xhr.onreadystatechange = function(){ ​ if(xhr.readyState==4&amp;&amp;xhr.status==200){ ​ console.log(xhr.responseText); ​ } ​ } ​ 6.方法 - send() ​ 作用:通知 xhr 开始向服务器发送请求 ​ 语法:xhr.send(body) ​ body:是请求体 ​ get : body的值为 null ​ xhr.send(null) ​ post: body的值为具体请求提交的数据 ​ xhr.send(“请求数据”) 4.AJAX的操作步骤​ 1.GET 请求 ​ 1.创建 xhr 对象 ​ 2.创建请求 - open() ​ 3.设置回调函数 - onreadystatechange ​ 判断状态,接收响应,业务处理 ​ 4.发送请求 - send() ​ xhr.send(null) 1.AJAX 发送 post 请求 1.请求数据要放在send()提交的 ​ var xhr = createXhr(); ​ xhr.open(“post”,”xxx”,true) ​ xhr.onreadystatechange = function(){ ​ xxxx xxxx ​ } ​ xhr.send(“uname=wangwc&amp;uage=35”); 2.Content-Type 的问题 ​ AJAX的post请求,默认会将Content-Type消息头的值更改为 “text/plain” , 所以导致提交参数无法获取. ​ 解决方案:将Content-Type的值更改为 “application/x-www-form-urlencoded” 即可 ​ xhr.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”); ​ 注意：需要放在create后，send前. 2.JSON 1.JSON介绍 ​ JSON : JavaScript Object Notation ​ JS 对象 表现形式 ​ 将复杂结构的字符串转换成JS对象的表现形式,方便前端解析 2.JSON的表现 ​ 1.JSON表示单个对象 ​ 1.使用{}表示一个对象 ​ 2.在{}中使用key:value的形式来表示属性(数据) ​ 3.key必须使用””引起来 ​ 4.value如果是字符串的话,也必须使用””引起来 ​ 5.多对 key:value之间使用,隔开 ​ var obj = { ​ “name”:”王老师”, ​ “age”:30, ​ “gender”:”男” ​ } ​ 取值：对象名.属性 ​ console.log(obj.name) ​ 2.使用JSON表示一个数组 ​ 1.使用[]来表示一个数组 ​ 2.数组中允许包含若干字符串 或 JS对象 ​ 1.使用JSON数组来表示若干字符串 ​ var arr = [“王老师”,”王夫人”,”王小超”]; ​ 2.使用JSON数组来表示若干对象 ​ 通过一个数组保存3个人的信息(name,age,gender) ​ var arr = [ ​ { ​ “name”:”王老师”, ​ “age”:35, ​ “gender”:”男” ​ }, ​ { ​ “name”:”王夫人”, ​ “age”:40, ​ “gender”:”男” ​ }, ​ { ​ “name”:”王小超”, ​ “age”:12, ​ “gender”:”男” ​ } ​ ]; 3.使用 jq 循环遍历数组 ​ 1.$arr.each(); ​ $arr : jQuery中的数组 ​ 语法: ​ $arr.each(function(i,obj){ ​ i : 遍历出来的元素的下标 ​ obj : 遍历出来的元素 ​ }); ​ 2.$.each() ​ $ -&gt; jQuery ​ 语法:$.each(arr,function(i,obj){ ​ }); 4.后台处理JSON ​ 1.前后端 JSON 的处理流程 ​ 1.在后端先查询出/得到复杂结构的数据 ​ 2.在后端将复杂结构的数据转换成符合JSON格式的字符串 ​ 3.在后端将JSON格式的字符串响应给前端 ​ 4.在前端将JSON格式的字符串再转换为JS对象/数组 ​ 5.在前端对JS对象/数组 进行循环遍历/取值操作 ​ 2.Python中的JSON处理 ​ 在Python中可以使用 json 类完成JSON的转换 ​ import json ​ jsonStr = json.dumps(元组|列表|字典) ​ return jsonStr ​ 注意:列表，元组，字典中的内容也必须是JSON可序列化的内容才可以 123456#注意：users=User.query.all() list=[] for user in users: list.append(user.to_dict()) return json.dumps(list) ​ 3.前端中的JSON处理 ​ 由于服务器端响应回来的数据时String,所以在前端对复杂结构的数据必须先转换成JS对象或数组,然后再取值或循环遍历 ​ 在 JS 中 : ​ var js对象 = JSON.parse(JSON字符串) 12345678910111213141516171819202122232425262728293031 &lt;script src=&quot;js/common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery-1.11.3.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#btnShow&quot;).click(function () &#123; var xhr=createXhr(); xhr.open(&apos;get&apos;,&apos;/04-json&apos;,true); if(xhr.readyState==4&amp;&amp;xhr.status==200) &#123; var res = xhr.responseText; res = JSON.parse(res); console.log(typeof(res)); console.log(res); $each(res, function (i, obj) &#123; console.log(&apos;id:&apos; + obj.id) console.log(&apos;uname:&apos; + obj.uname) console.log(&apos;nickname:&apos; + obj.nickname) &#125;); &#125; xhr.send(null) &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=&quot;btnShow&quot;&gt;显示&lt;/button&gt;&lt;/body&gt; 1.使用 jquery 操作 AJAX1.$obj.load(url[,data][,callback])​ 作用:远程加载数据并加载到$obj元素中 ​ url : 远程请求的地址 ​ data : 要传递的参数 ​ 1.字符串拼参数,采用 get 方式发送请求 ​ var params=”name=zsf&amp;age=80” ​ 2.使用 JSON 格式拼参数,采用 post 方式发送请求 ​ var params={ ​ “name”:’基尼’, ​ “age”:”85” ​ } ​ callback : 请求和响应完成之后的回调函数 ​ function(resText,statusText){ ​ resText : 响应回来的文本 ​ statusText : 响应回来的状态文本 ​ } 2.$.get(url[,data][,callback][,type])​ 作用:使用 get 方式异步的向服务器发送请求 ​ url : 远程请求的地址 ​ data : 请求参数 (可选) ​ callback : 响应成功后的回调函数(可选) ​ function(resText){ ​ resText : 表示响应回来的数据 ​ } ​ type : 响应回来的数据的数据类型 ​ 1.html : 响应回来的文本当成HTML文本处理 ​ 2.text : 响应回来的文本当成text文本处理 ​ 3.json : 响应回来的文本当成JSON进行处理(转换成JS对象) ​ 4.script : 响应回来的是JS的代码片段 3.$.post(url[,data][,callback][,type])​ 各参数作用同 $.get 4.$.ajax()​ 语法：$.ajax({ SETTINGS }); ​ SETTINGS中的常用设置选项 ​ 1. url ：字符串，表示请求的地址 ​ 2. type : 字符串，请求方式，’get’ 或 ‘post’ ​ 3.async : Boolean,是否采用异步方式发送请求 ​ 4.data ： 要传递到服务器的参数 ​ ①字符串 ​ “name1=value1&amp;name2=value2” ​ ②JSON / Map ​ { ​ “name1”:”value1”, ​ “name2”:”value2” ​ } ​ 5.dataType : 字符串，响应回来的数据格式 ​ html,xml,text,script,json ​ jsonp : 跨域时候使用 ​ 6.sucess : 请求成功时的回调函数 ​ function(data){ ​ data : 是响应回来的数据 ​ } 12345678910//向 /05-ajax 发送一个同步请求，并接收响应数据，响应回来的内容是一个JSON字符串$.ajax(&#123; url:&apos;/05-ajax&apos;, type:&apos;get&apos;, dataType:&apos;json&apos;, async:false, success:function(data)&#123; data就是响应回来的数据 &#125;&#125;)]]></content>
      <categories>
        <category>Python Web</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2019%2F01%2F07%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式编程​ 函数式编程是指用一系列函数解决问题 ; 函数是一等公民 说明: ​ 用每一个函数完成细小的功能,一系列函数的任意组成可以解决大问题 ​ 函数仅接受输入并产生输出,不包含任何可能影响输出的内部状态 函数的可重入性: 当一个函数没有访问除局部变量以外的变量,则此函数为可重入函数 ​ 高阶函数 High Order Function 什么是高阶函数 ​ 满足下列条件中一个的函数即为高阶函数 ​ 函数接受一个或多个函数作为参数传入 ​ 函数返回一个函数 python 内建的高阶函数 map, filter, sorted map 函数: map(func, *iterables) 返回可迭代对象,此可迭代对象用func对可迭代对象iterables中的每个元素作为参数计算后得到结果,再返回.当最短的一个可迭代对象不再提供数据时迭代结束 123456789101112131415161718192021def power2(x): # print(&quot;power2被调用, x=&quot;, x) return x ** 2# 生成一个可迭代对象,此可迭代对象可以生成 1~9的自然数的平方for x in map(power2, range(1, 10)): print(x) # 1, 4, 9, 16# 生成一个可迭代对象,此可迭代对象可以生成 # 1**4, 2**3, 3**2, 4**1# pow(x, y, z=None)for x in map(pow, range(1, 5), range(4, 0, -1)): print(x)print(&apos;-----------------&apos;)for x in map(pow, [1, 2, 3, 4], [4, 3, 2, 1], range(5, 100)): print(x) 练习: 求: 12 + 22 + 32 + … + 92的和 求: 13 + 23 + 33 + … + 93的和 求: 19 + 28 + 37 + … + 91的和 123456789101112131415161718192021# 求: 1**2 + 2**2 + 3**2 + ... + 9**2的和def power2(x): return x ** 2# 方法1# s = 0# for x in map(power2, range(1, 10)):# s += x# print(s)# 方法2# m = map(power2, range(1, 10))# print(sum(m))# 方法3print(sum(map(power2, range(1, 10))))# 求: 1**3 + 2**3 + 3**3 + ... + 9**3的和print(sum(map(lambda x:x**3, range(1, 10))))# 求: 1**9 + 2**8 + 3**7 + ... + 9**1的和print(sum(map(pow, range(1, 10), range(9, 0, -1)))) filter函数 filter(func, iterable) 返回一个可迭代对象,此可迭代对象将对iterable获取到的数据用函数func进行筛选; func将对iterable中的每个元素进行求值，返回False则丢弃，返回True则保留此数据 1234567891011121314# 判断x是否是奇数，如果是奇数返回True,否则...def isodd(x): return x % 2 == 1# 生成1~100的奇数for x in filter(isodd, range(100)): print(x)# 生成1~100以内的偶数放到列表even中even = [x for x in filter( lambda x: x % 2 == 0, range(1, 100))]print(even) 练习: 把1～１００之间的全部素数放在列表primes中 123456789101112131415def isprime(x): if x &lt; 2: return False for i in range(2, x): if x % i == 0: return False return True primes = [x for x in filter( isprime, range(100))]print(primes) sorted 函数: 作用： 将原可迭代对象的数据进行排序，生成排序后的列表 格式: ​ sorted(iterble, key=None, reverse=False) 说明: ​ iterable 是可迭代对象 ​ key 函数是用来提供比较值的函数，这个值将作用排序的依据 ​ reverse 标志用来设置是否降序排序 123456789101112131415# 此示例示意sorted函数的用法L = [5, -2, -4, 0, 3, 1]L2 = sorted(L) # [-4, -2, 0, 1, 3, 5]print(&apos;L2=&apos;, L2)L3 = sorted(L, reverse=True)print(&quot;L3=&quot;, L3) # [5, 3, 1, 0, -2, 4]L4 = sorted(L, key=abs) # [0, 1, -2, 3, -4, 5]print(L4)names = [&apos;Tom&apos;, &apos;Jerry&apos;, &apos;Spike&apos;, &apos;Tyke&apos;]L5 = sorted(names, key=len)print(L5) #[&apos;Tom&apos;,&apos;Tyke&apos;,&apos;Jerry&apos;,&apos;Spike&apos;] # 3 4 5 5L6 = sorted(names) # ???print(&apos;L6=&apos;, L6) 练习: names = [‘Tom’, ‘Jerry’, ‘Spike’, ‘Tyke’] 排序的依据是’moT’ ‘yrreJ’, ‘ekipS’ ‘ekyT’ 结果是: ​ [‘Spike’, ‘Tyke’, ‘Tom’, ‘Jerry’] ​ (注:如果没有现成的函数可用,需要自己写函数) 12345678910names = [&apos;Tom&apos;, &apos;Jerry&apos;, &apos;Spike&apos;, &apos;Tyke&apos;]# 排序的依据是&apos;moT&apos; &apos;yrreJ&apos;, &apos;ekipS&apos; &apos;ekyT&apos;def fk(s): r = s[::-1] print(&quot;字符串&quot;, s, &apos;排序的依据是&apos;, r) return rL = sorted(names, key=fk)print(L) 递归函数 recursion 函数直接或间接的调用自身 1234567def say_story(): print(&quot;从前有座山,山上有座庙,庙里有个老和尚讲故事:&quot;) say_story() print(&quot;讲故事结束&quot;)say_story()print(&quot;程序结束&quot;) 示例: # 函数直接调用自己 def f1(): ​ f1() # 直接调用自己 f1() # 函数间接调用自己 def fa(): ​ fb() def fb(): ​ fa() # 间接的调用自己 fa() 说明: 递归一定要控制递归的层数,当符合一定条件时要终止递归调用 几乎所有的递归都能用while循环来代替 优缺点: 优点是可以把问题简单化,让思路更为清晰,代码更简洁 缺点是因系统环境影响大,当递归深度太大时,可能会得到不可预知的结果 递归函数调用分为两个阶段: 递推阶段 ​ 从原问题出发,按递归公式递推从未知到已知,最终到达递归终止条件 回归阶段 ​ 按递归终止条件求出结果,逆向逐步代入递归公式,回归原问题求解 12345678910# 此示例示意递归调用和根据条件结束递归def fx(n): print(&quot;递归进入第&quot;, n, &quot;层&quot;) if n == 3: return fx(n + 1) # 进入下一层 print(&quot;递归退出第&quot;, n, &quot;层&quot;)fx(1)print(&apos;程序结束&apos;) 123456789def myfac(n): # 如果n为1则知道 1的阶乘是1,直接返回 if n == 1: return 1 # 否则,进入递推阶段等待下一个结果后再返回 return n * myfac(n-1)print(myfac(5)) # 120print(myfac(50)) # ??? 练习: 用递归的方式求1 + 2 + 3 + … + n 的和 def mysum(n): ​ … print(mysum(100)) # 5050 1234567def mysum(n): if n == 1: return 1 return n + mysum(n - 1)print(mysum(100)) # 5050# print(mysum(1000)) # 崩溃 crash 思考题: 已知有五位朋友在一起 ​ 第五位朋友说他比第四位朋友大2岁 ​ 第四位朋友说他比第三位朋友大2岁 ​ 第三位朋友说他比第二位朋友大2岁 ​ 第二位朋友说他比第一位朋友大2岁 ​ 第一位朋友说他10岁 def getage(n): # 求第n个人的年龄 123456def getage(n): # 求第n个人的年龄 if n == 1: return 10 return getage(n - 1) + 2print(getage(5)) 闭包 closure 什么是闭包 ​ 闭包是引用了此函数外部变量的函数 闭包必须满足三个条件: ​ 1. 必须有内嵌函数 ​ 2. 内嵌函数必须引用外部函数中的变量 ​ 3. 外部函数返回值必须是内嵌函数 12345678910111213141516171819202122232425# 定义很多个函数每个函数求 x**y次方,y是可变的# 示意def pow2(x): return x**2def pow3(x): return x**3# ...def pow99(x): return x**99# 以下用闭包来实现def make_power(y): def fn(x): return x ** y return fnpow2 = make_power(2) # pow2绑定一个闭包print(&quot;5的平方是:&quot;, pow2(5)) # 25pow3 = make_power(3)print(&quot;5的立方是:&quot;, pow3(5))pow99 = make_power(99)print(&apos;2的99次方是:&apos;, pow99(2)) 练习: 编写程序求 1 ~ 20的阶乘的和 ​ 即: ​ 1! + 2! + 3! + … + 20! 1234567891011121314151617181920212223242526272829303132333435363738# 方法1# s = 0# for x in range(1, 21):# # 计算x的阶乘# r = 1# for y in range(1, x + 1):# r *= y# # 把x! r加到s中# s += r# 方法2# def myfac(x):# r = 1# for y in range(1, x + 1):# r *= y# return r# s = 0# for x in range(1, 21):# # 计算x的阶乘# r = myfac(x)# # 把x! r加到s中# s += r# 方法3# def myfac(x):# r = 1# for y in range(1, x + 1):# r *= y# return r# s = sum(map(myfac, range(1, 21)))# 方法4import maths = sum(map(math.factorial, range(1, 21)))print(s) # 已知有列表: ​ L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20] ​ 1) 写个函数print_list(lst) 打印出所有的数字,即: ​ print_list(L) # 打印3 5 8 10 13… ​ 2) 写一个函数sum_list(lst) 返回这个列表中所有数字的和 ​ print(sum_list(L)) # 106 注: ​ type(x) 可以返回一个变量的类型,如: ​ >&gt;&gt; type(20) is int # True ​ >&gt;&gt; type([1, 2, 3]) is list # True 1234567891011121314151617181920212223242526272829L = [[3, 5, 8], 10, [[13, 14], 15, 18], 20]# 1) 写个函数print_list(lst) 打印出所有的数字,即:def print_list(lst): for x in lst: # 当x是数字时,打印这个数字 if type(x) is int: print(x) # 当x是列表时,打印列表 else: print_list(x)print_list(L) # 打印3 5 8 10 13...# 2) 写一个函数sum_list(lst) 返回这个列表中所有数字的和def sum_list(lst): s = 0 for x in lst: # 如果x是整数 if type(x) is int: s += x # 如果x是列表,则s+= 列表的所有元素的和 else: s += sum_list(x) return sprint(sum_list(L)) # 106 装饰器 decorator(专业提高篇) 作用: ​ 通常在不改变原函数的情况下,改变或添加原函数功能 什么是装饰器: ​ 装饰器是一个函数,能常用来包装另一个函数或类(后面才讲) 函数装饰器 是指装饰器函数,传入的是函数,返回的也是函数 语法: def 装饰器函数名(形参): ​ 语句块 ​ return 函数对象 @装饰器函数名 def 函数名(形参列表): ​ 语句块 12345678910111213141516171819# 以下函数是装饰器函数,fn用来绑定被装饰函数def mydeco(fn): def fx(): print(&quot;++++++这是fn被调用之前++++&quot;) fn() print(&quot;------这是fn被调用之后----&quot;) return fx@mydecodef myfunc(): print(&quot;myfunc被调用!&quot;)# 以上@mydeco等同于在def myfunc之后加了# 如下语句# myfunc = mydeco(myfunc)myfunc()myfunc()myfunc() 1234567891011121314151617181920212223# 此示例用装饰器改变原来函数的调用流程(业务流程)# 银行业务# 小铭同学def privileged_check(fn): def fx(n, x): print(&quot;正在进行权限验证....&quot;) fn(n, x) return fx# -------以下是魏老师写的程序------@privileged_checkdef save_money(name, x): print(name, &apos;存钱&apos;, x, &apos;元&apos;)@privileged_checkdef withdraw(name, x): print(name, &apos;取钱&apos;, x, &apos;元&apos;)# -------以下是小张写的程序------save_money(&apos;小王&apos;, 200)save_money(&apos;小赵&apos;, 400)withdraw(&apos;小李&apos;, 500) ##### 函数的文档字符串 函数内第一次未赋值给任何变量的字符串是函数的文档字符串 语法: ​ def 函数名(参数列表): ​ “函数的文档字符串” ​ 函数语句块 示例: ​ def cba(): ​ “””这是一块文档字符串 ​ 以下省略300字…””” ​ pass ​ >&gt;&gt; help(cba) 函数的 doc属性 doc属性用于记录函数的文档字符串 如: ​ print(cba.doc) 函数定义语句(def语句)的完整语法: [@装饰器名1] [@装饰器名2] […] def 函数名([位置形参], [*元组形参], [命名关键字形参], [**字典形参]): ​ “文档字符串” ​ 语句块 面试题: L = [1, 2] def f(n, lst=[]): ​ ‘’’ lst 绑定的列表[] 会在def语句 ​ 创建时创建,且和f绑定的函数一同存在’’’ ​ lst.append(n) ​ print(lst) f(3, L) # [1, 2, 3] f(4, L) # [1, 2, 3, 4] f(100) # [100] f(200) # [100, 200] f(200) # [100, 200, 200] 解决方法: # 以上函数改写如下: def f(n, lst=None): ​ if lst is None: ​ lst = [] ​ lst.append(n) ​ print(lst) 迭代器 Iterator 什么是迭代器 ​ 迭代器是访问可迭代对象的工具 ​ 迭代器是指用iter(obj) 函数返回的对象(实例) ​ 迭代器可以用next(it) 函数获取可迭代对象的数据 迭代器函数: iter(iterable) 从可迭代对象中返回一个迭代器,iterable 必须是能提供一个迭代器的对象 next(iterator) 从迭代器iterator中获取下一个记录,如果无法获取下一条记录,则触发StopIteration异常通知 说明: 迭代器只能往前取值,不会后退 示例: L = [1, 3, 5, 7] it = iter(L) # 让iter函数从L中获取迭代器 ​ # it 绑定的是迭代器 print(next(it)) # 1 print(next(it)) # 3 print(next(it)) # 5 print(next(it)) # 7 print(next(it)) # StopIteration 用迭代器和while来代替for语循环 123456789101112L = [2, 3, 5, 7]it = iter(L) # 获取迭代器while True: try: x = next(it) print(x) except StopIteration: breakprint(&quot;--------------------&quot;)for x in L: print(x) 练习: 有一个集合: ​ s = {‘唐僧’, ‘悟空’, ‘八戒’, ‘沙僧’} 用for语句遍历所有元素如下: ​ for x in s: ​ print(x) ​ else: ​ print(“遍历结束”) 请将上面的for语句改写为while语句和迭代器实现 123456789101112131415s = &#123;&apos;唐僧&apos;, &apos;悟空&apos;, &apos;八戒&apos;, &apos;沙僧&apos;&#125;for x in s: print(x)else: print(&quot;遍历结束&quot;)print(&quot;=============================&quot;)myit = iter(s) # 获取拿到迭代器while True: try: x = next(myit) print(x) except StopIteration: print(&quot;遍历结束&quot;) break 练习: 一个球从100米高空落下,每次落地后反弹高度为原高度的一半地,再落下, ​ 1) 写程序算出皮球在第10次落地后反弹多高 ​ 2) 打印10次后球出共经过多少米路程 1234567891011121314151617181920212223def get_last_height(meter, times): &apos;&apos;&apos;根据小于的初始高度meter和次数,返回最后的反弹高度&apos;&apos;&apos; for _ in range(times): meter /= 2 return meterprint(&quot;球第10次落地后的高度是:&quot;, get_last_height(100, 10)) def get_distance(meter, times): s = 0 # 记录球的总行程 for _ in range(times): # 记录下落时行程 s += meter # 算出反弹高度 meter /= 2 # 记录反弹的行程 s += meter return sprint(&quot;球在第10次反弹后的总行程是:&quot;, get_distance(100, 10), &quot;米&quot;) 分解质因数, 输入一个正整数,分解质因数. 如输入 : 90 则打印: 90 = 233*5 (质因数是指最小能被原数整除的素数(不包括1)) 1234567891011121314151617181920212223def get_zhiyin_list(x): &quot;&quot;&quot;此函数将返回包含x的所有质数数的列表 如:x = 90 则返回 [2, 3, 3, 5] &quot;&quot;&quot; L = [] # 循环查找x的质数,如果找到质数入就加入到L列表中,直到x等于1为止 while x &gt; 1: # 以下循环只找一个质因数,找以后循环停止 # 再返回上面的循环 for i in range(2, x + 1): if x % i == 0: # 整除了一定 # 此时i一定是质因数 L.append(i) x = int(x / i) break return Ln = int(input(&quot;请输入一个大于零的整数: &quot;))L = get_zhiyin_list(n)s = &apos;*&apos;.join( (str(x) for x in L) )print(n, &apos;=&apos;, s) 生成器 Generator (python2.5及之后) 生成器是能够动态提供数据的可迭代对象 生成器是在运行时生成数据,与容器类不同,它通常不会在内存中保存大量的数据,而是现用现生成 生成器有两种: \1. 生成器函数 \2. 生成器表达式 生成器函数: 含有yield语句的函数是生成器函数,此函数被调用将返回一个生成器对象 ​ yield 翻译为(产生或生成) yield 语句 语法: ​ yield 表达式 说明: ​ yield 用于 def 函数中,目的是将此函数作用生成器函数使用 ​ yield 用来生成数据 ,供迭代器的next(it)函数取值 1234567891011121314151617181920212223# 此示例示意生成器函数的定义和使用def myyield(): &apos;&apos;&apos;这是一个生成器函数, 此函数用来动态生成2,3,5,7&apos;&apos;&apos; yield 2 yield 3 yield 5 yield 7# 用生迭代器访问这个生成器函数gen = myyield() # 生成器函数调用将返回一个生成器print(gen) # gen是一个生成器对象it = iter(gen) # 拿到迭代器print(next(it)) # 2print(next(it)) # 3print(next(it)) # 5print(next(it)) # 7# print(next(it)) # StopIterationprint(&apos;---以下用for语句访问生成器---&apos;)for x in myyield(): print(x) 生器函数说明: \1. 生成器函数调用将返回一个生成器对象,生成器对象是可迭代对象 \2. 在生成器函数内调用return语句会触发一个 StopIteration 异常(即生成数据结束) 123456789# 此示例示意用生成器函数创建生成从0开始到n结束的一系列整数(不包含n)def myinteger(n): # integer(整数) i = 0 # 设置初始值为0 while i &lt; n: yield i # 生成i给next(it) 调用 i += 1 # 为生成下一个数做准备for x in myinteger(10000000000000000000): print(x) 练习: 写一个生成器函数 myeven(start, stop) 用来生成从start开始到stop结束区间内的一系列偶数(不包含stop) 123456789101112def myeven(start, stop): for x in range(start, stop): if x % 2 == 0: yield xevens = list(myeven(10, 20))print(evens) # [10, 12, 14, 16, 18]for x in myeven(5, 10): print(x) # 6 8L = [x for x in myeven(0, 10)]print(L) # [0, 2, 4, 6, 8] 生成器表达式: 语法 ​ (表达式 for 变量 in 可迭代对象 [if 真值表达式]) 说明: ​ if 子句可以省略 作用: ​ 用推导式形式创建一个新的生成器 示例: ​ gen = (x ** 2 for x in range(1, 5)) ​ it = iter(gen) ​ next(it) # 1 ​ next(it) # 4 ​ next(it) # 9 ​ next(it) # 16 ​ next(it) # StopIteration 练习: 已知有列表: ​ L = [2, 3, 5, 7, 10, 15] 1) 写一个生成器函数,让此函数能动态提供数据,数据为原列表的数字的平方+1 2) 写一个生成器表达式,让此表达式能动态提供数据,数据依旧为原列表数字的平方+1 3) 生成一个列表,此列表内的数据为原列表的数字的平方+1 123456789101112131415161718192021def mygen_fun(lst): for x in lst: yield x ** 2 + 1L2 = list(mygen_fun(L))print(L2)# def mygen_fun2():# for x in L:# yield x ** 2 + 1# L2 = list(mygen_fun())# print(L2)# 2) 写一个生成器表达式,让此表达式能动态提供数据,数据依旧为原列表数字的平方+1L3 = list( (x ** 2 + 1 for x in L) )print(&apos;L3=&apos;, L3)# 3) 生成一个列表,此列表内的数据为原列表的数字的平方+1L4 = [x ** 2 + 1 for x in L]print(&quot;L4=&quot;, L4) 看下列程序的输出结果有什么不同,为什么? # 第一段程序 L = [2, 3, 5, 7] L2 = [x * 10 for x in L] it = iter(L2) print(next(it)) # 20 L[1] = 30 print(next(it)) # 30 # 第二段程序 L = [2, 3, 5, 7] L2 = (x * 10 for x in L) # &lt;-此处已修改 it = iter(L2) print(next(it)) # 20 L[1] = 30 print(next(it)) # 300 练习: 写一个生成器函数,给出开始值begin,和终止值end,此生成器函数生成begin~end 范围内的全部素数(不包含end) 1234567891011121314151617181920def is_prime(x): if x &lt; 2: return False for i in range(2, x): if x % i == 0: return False return Truedef primes(begin, end): for x in range(begin, end): # 如果x是素数,则用yield把这个送回给调用者 if is_prime(x): yield xL = list(primes(10, 20))print(L) # [11, 13, 17, 19]# 求: 200以内全部素数的和:print(sum(primes(0, 200))) 迭代工具函数 作来生成一个个性化的可迭代对象 函数 说明 zip(iter1[, iter2, …]) 返回一个zip生成器对象,此对象用于生成元组,元组的数据分别来自于参数中的每个可迭代对象,生成元组的个数由最小的可迭代对象大小决定 enumerate(iterable, start=0) 返回一个enumerate生成器对象,此对象生成类型为(索引,值)的元组,默认索引从零开始,也可以用start指定 示例: ​ numbers = [10086, 10000, 10010,95588] ​ names = [‘中国移动’,’中国电信’,’中国联通’] ​ for t in zip(numbers, names): ​ print(t) ​ for n, m in zip(numbers, names): ​ print(m,’的客服电话是’, n) ​ d = dict(zip(numbers, names)) ​ for t in zip(numbers, names, range(1000)): ​ print(t) zip函数的实现(用生成器函数实现) 123456789101112131415161718192021numbers = [10086, 10000, 10010,95588]names = [&apos;中国移动&apos;,&apos;中国电信&apos;,&apos;中国联通&apos;]# def myzip(*args):def myzip(iter1, iter2): # 先拿到两个对象的迭代器 it1 = iter(iter1) it2 = iter(iter2) while True: try: a = next(it1) b = next(it2) yield (a, b) except StopIteration: return # 此生成器函数生成结束for t in myzip(numbers, names): print(t)d = dict(myzip(numbers, names))print(d) enumerate 示例 names = [‘中国移动’, ‘中国电信’, ‘中国联通’] for t in enumerate(names): ​ print(t) # (1, ‘中国移动’), … 写一个生成器函数 myxrange(start, stop, step) 来生成一系列整数 ​ 要求功能与range完全相同 ​ 不允许调用range函数和列表 ​ 然后用自己写的myxrange函数求 1 ~ 100内奇数的平方和 12345678910111213141516171819def myxrange(start, stop=None, step=1): # 调用开始和结束的值 if stop is None: stop = start start = 0 # 正向生成: if step &gt; 0: while start &lt; stop: yield start # 生成当前值 start += step elif step &lt; 0: while start &gt; stop: yield start start += step # 加上一个负数L = [x**2 for x in myxrange(1, 101, 2)]print(sum(L)) 写一个myfilter生成器函数,功能与filter函数功能完全相同 12345678910def myfilter(fn, iter1): for x in iter1: if fn(x) == True: yield xL = [x for x in myfilter( lambda x: x%2, range(10))] # L = [1, 3, 5, 7, 9]print(L)]]></content>
      <categories>
        <category>python函数</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数 function什么是函数​ 函数是可以重复执行的语句块,可以重复的调用 ​ 函数是面向过程编程的最小单位 作用: ​ \1. 用于封装语句块,提高代码的重用性 ​ \2. 定义用户级别的函数 def 语句 语法: ​ def 函数名(形参列表): ​ 语句块 说明: ​ \1. 函数的名字就是语句块的名称 ​ \2. 函数名的命名规则写变量名的规则相同(必须是标识符) ​ \3. 函数名是一个变量(不要轻易对其赋值) ​ \4. 函数有自己的名字空间,在函数外部不可能访问函数内部的变量,在函数内部可以访问函数外部的变量 ​ 要让函数处理处部的数据最好用参数给函数传入一些数据 ​ \5. 函数如果不需要传入参数,参数列表可以为空 ​ \6. 语句部分不能为空.如果为空需要填充pass语句 12345678910# 此示例示意函数的定义和调用def say_hello(): print(&quot;hello world!&quot;) print(&quot;hello Tarena!&quot;) print(&quot;hello everyone!&quot;)say_hello() # 调用一次say_hellosay_hello() # 调用第二次say_hello() # 第三次 12345678910# 此示例示意写一个函数,此函数的功能是给它两个数据,让它把最大值的数据打印出来def mymax(a, b): m = a if b &gt; m: m = b print(&quot;最大值的数据是:&quot;, m)mymax(100, 200)mymax(&quot;ABC&quot;, &quot;123&quot;) 函数调用 函数名(实际调用传递参数) 说明: ​ 函数调用是一个表达式.如果函数内没有return语句.默认返回None对象 练习: 写一个函数myadd,此函数中的参数列表里有两个参数x, y,此函数的功能是打印 x + y的和: 如: ​ def myadd(…): ​ … # …是需要填充的部分 ​ ​ myadd(100, 200) # 打印300 ​ myadd(“ABC”, “123”) # 打印 ABC123 return 语句 语法: ​ return [表达式] ​ 注: [] 代表其中的内容可省略 作用: ​ 用于函数中,结束当前函数的执行,返回到调用函数的地方,同时返回一个对象的引用关系 说明: ​ \1. return 语句后跟的表达式可以省略,省略后相当于 return None ​ \2. 如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句) 1234567891011121314151617181920# 此示例示意return语句的作用和用法def say_hello2(): print(&quot;hello aaa&quot;) print(&quot;hello bbb&quot;) # return # 等同于return None # return 1 + 2 return [1, 2, 3, 3 + 1] print(&quot;hello ccc&quot;)r = say_hello2() print(&quot;r=&quot;, r) print(&quot;程序结束&quot;)# hello aaa# hello bbb# r= [1, 2, 3, 4]# 程序结束 12345678910111213141516# 此示例示意return语句的作用和用法def say_hello2(): print(&quot;hello aaa&quot;) print(&quot;hello bbb&quot;) print(&quot;hello ccc&quot;) # 此处相当于有条语句 return Noner = say_hello2() # 调用print(&quot;r=&quot;, r) # None# hello aaa# hello bbb# hello ccc# r= None 练习: \1. 写一个函数 myadd2, 实现给出两个数,返回这两个数的和 ​ 如: ​ def myadd(x, y): ​ ….. ​ a = int(input(“请输入第一个数: “)) ​ b = int(input(“请输入第二个数: “)) ​ print(“您输入的这两个数的和是”, myadd2(a, b)) 12345678910111213def myadd2(x, y): z = x + y return z # return x + ya = int(input(&quot;请输入第一个数: &quot;))b = int(input(&quot;请输入第二个数: &quot;))print(&quot;您输入的这两个数的和是&quot;, myadd2(a,b))#请输入第一个数: 1#请输入第二个数: 2#您输入的这两个数的和是 3 \2. 写一个函数mymax3,返回三个数中最大的一个值 ​ def mymax3(a, b, c): ​ …. # 此处自己实现 ​ ​ print(mymax3(100, 300, 200)) # 300 ​ print(mymax3(“ABC”, “123”, “abc”)) # abc 123456789101112131415161718192021222324# 方法1# def mymax3(a, b, c):# zuida = a# if b &gt; zuida:# zuida = b# if c &gt; zuida:# zuida = c# return zuida# 方法2# def mymax3(a, b, c):# z = a if a &gt; b else b# z = z if z &gt; c else c# return zdef mymax3(a, b, c): return max(a, b, c) # z = max(a, b) # z = max(z, c) # return zprint(mymax3(100, 300, 200)) # 300print(mymax3(&quot;ABC&quot;, &quot;123&quot;, &quot;abc&quot;)) # abc \3. 写一个函数 input_numbers,如下: ​ def input_numbers(): ​ …. # 此处自己实现 ​ 此函数用来获取用户循环输入的正整数,当用户输入负数时结束输入 ​ 将用户输入的数字以列表的形式返回,再用内建函数max,min,sum求出用户输入数的最大值,最小值及和 ​ L = input_numbers() ​ print(L) # 打印列表 ​ print(“用户输入的最大数是:”, max(L)) ​ print(“用户输入的最小数是:”, min(L)) ​ print(“用户输入的数的和是:”, sum(L)) 123456789101112131415def input_numbers(): lst = [] while True: n = int(input(&quot;请输入正整数(负数结束):&quot;)) if n &lt; 0: return lst # break # return lst lst.append(n) # return lstL = input_numbers()print(L) # 打印列表print(&quot;用户输入的最大数是:&quot;, max(L))print(&quot;用户输入的最小数是:&quot;, min(L))print(&quot;用户输入的数的和是:&quot;, sum(L)) 练习: \1. 写一个函数get_chinese_char_count(s) 函数,此函数实现的功能是给定一个字符串,返回这个字符串中中文字符的个数 ​ def get_chinese_char_count(s): ​ …. # 此处自己实现 ​ ​ s = input(“请输入中英文混合的字符串: “) ​ print(“您输入的中文字符的个数是:”, ​ get_chinese_char_count(s)) 12345678910111213def get_chinese_char_count(s): count = 0 # 记录中文字符的个数 # 此处用来记中文数 for ch in s: if ord(ch) &gt; 127: count += 1 return counts = input(&quot;请输入中英文混合的字符串: &quot;)print(&quot;您输入的中文字符的个数是:&quot;, get_chinese_char_count(s)) \2. 定义两个函数: ​ sum3(a, b, c) 用于返回三个数的和 ​ pow3(x) 用于返回x的三次方(立方) ​ 用以上函数计算: ​ 1) 计算 1的立方+ 2的立方 + 3的立方 ​ 2) 计算 1 + 2 + 3的和的立方 ​ 即:13 + 23+33 和 (1+2+3)3 1234567891011121314def sum3(a, b, c): return a + b + cdef pow3(x): return x ** 3# 1) 计算 1的立方+ 2的立方 + 3的立方s = sum3(pow3(1), pow3(2), pow3(3))print(s)# 2) 计算 1 + 2 + 3的和的立方s = pow3(sum3(1, 2, 3))print(s)# 即:1**3 + 2**3+3**3 和 (1+2+3)**3 函数的参数: 1.函数实际调用参数传递(把数据给函数) 2.函数的形式参数(从调用者拿来(接收)数据) 函数的实际调用参数传递 传递方式: ​ 1.位置传参 ​ 1.1 序列传参 ​ 2.关键字传参 ​ 2.2 字典关键字传参 位置传参: 实际参数(实参)的对应关系与形式参数(形参)的对应关系是按位置来依次对应的 示意: ​ def mymin(a, b, c): ​ pass ​ # ^ ^ ^ ​ mymin( 1, 2, 3) 说明: 实参个数必须与形参个数相同 12345678# 此示例示意位置传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)myfun1(1, 2, 3) # 1--&gt;a 2--&gt; b...myfun1(4, 5, 6) # 4--&gt;a 5--&gt; b... 序列传参: 序列: 字符串,列表,元组 序列传参是指在函数调用过程中,用*(星号)将序列拆解后按位置进行传递的传参方式 12345678910111213# 此示例示意序列传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)s1 = [11, 22, 33]# myfun1(s1[0], s1[1], s1[2])myfun1(*s1) # 相当于 myfun1(11, 22, 33)s2 = (44, 55, 66)s3 = &quot;ABC&quot;myfun1(*s2)myfun1(*s3) 说明: ​ 序列传参时,序列拆解的位置将与形参一一对应 ​ 序列的位置信息对应相应的参数位置 关键字传参 关键字传参是指传参时,按着形参的名称给形参赋值 实参和形参按名称进行匹配 示例见: 12345678910# 此示例示意关键字传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)myfun1(c=300, b=200, a=100)myfun1(b=20, c=30, a=10)# myfun1(b=2, c=3, b=1) # 报错 说明: ​ 实参和形参可以不按位置进行匹配. 字典关键字传参 是指实参为字典 将字典用 **(双星号) 拆解后进行关键字传参的传参方式 12345678910111213141516# 此示例示意字典关键字传参def myfun1(a, b, c): print(&quot;a的值是:&quot;, a) print(&quot;b的值是:&quot;, b) print(&quot;c的值是:&quot;, c)d1 = &#123;&apos;c&apos;: 33, &apos;b&apos;:22, &apos;a&apos;:11&#125;# myfun1(d1[&apos;a&apos;], d1[&apos;b&apos;], d1[&apos;c&apos;])# myfun1(a=d1[&apos;a&apos;], b=d1[&apos;b&apos;], c=d1[&apos;c&apos;])myfun1(**d1) # 等同于myfun1(a=11,b=22,c=33)d2 = &#123;&apos;c&apos;: 33, &apos;b&apos;:22, &apos;a&apos;:11, &apos;d&apos;:44&#125;# myfun1(**d2) # 报错# a的值是: 11# b的值是: 22# c的值是: 33 说明: ​ 字典的键名和形参名必须一致 ​ 字典的键名必须是字符串,且必须为标识符的命名规则 ​ 字典的键名要在形参中存在 函数综合传参 函数的传参方式,在能确定形参能唯一匹配到相应实参的情况下可以任意组合 函数的位置传参要先于关键字传参 \1. 函数的位置传参和序列传参可以混合使用,且可以顺序颠倒 ​ myfun1(100, *[200, 300]) ​ myfun1(*[100, 200], 300) ​ myfun1([100], 200, [300]) \2. 函数位置传参和关键字传参可以混合使用 ​ myfun1(100, c=300, b=200) ​ myfun1(100, **{“c”:300}, b=200) ——-以下讲的函数的定义及函数的形参—- 函数的缺省参数 语法: ​ def 函数名(形参名1=默认实参1, 形参名2=默认实参2, …): ​ 语句块 123456789101112# 此示例示意函数的缺省参数def info(name, age=1, address=&quot;不详&quot;): print(name, &quot;今年&quot;, age, &apos;岁&apos;, &apos;家庭住址:&apos;, address)info(&quot;魏明择&quot;, 35, &apos;北京市朝阳区&apos;)info(&quot;Tarena&quot;, 16)info(&quot;张飞&quot;)#魏明择 今年 35 岁 家庭住址: 北京市朝阳区# Tarena 今年 16 岁 家庭住址: 不详#张飞 今年 1 岁 家庭住址: 不详 说明: ​ \1. 缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数 ​ \2. 缺省参数可以有0个,1个或多个,甚至全部都是缺省参数 示例: ​ def fn(a, b=10, c): # 错的 ​ pass ​ def fn(a=0, b=10, c=20): # 对的 ​ pass ​ 练习: 写一个函数 myadd,此函数可以计算两个数,三个数及四个数的和. ​ 如: ​ def myadd(…): ​ … ​ print(myadd(10, 20)) # 30 ​ print(myadd(100, 200, 300)) # 600 ​ print(myadd(1, 2, 3, 4)) # 10 123456def myadd(a, b, c=0, d=0): return a + b + c + dprint(myadd(10, 20)) # 30print(myadd(100, 200, 300)) # 600print(myadd(1, 2, 3, 4)) # 10 函数形参的定义方式: 位置形参 星号元组形参 命名关键字形参 双星号字典形参 位置形参: 语法: ​ def 函数名(形参名1, 形参名2, …): ​ 语句块 星号元组形参 语法: ​ def 函数名(* 元组形参名): ​ 语句块 作用: ​ 收集多余的位置传参 说明: ​ 元组形参名一般命名为 ‘args’ 123456789101112# 此示例示意星号元组形参的定义及使用def func(*args): print(&quot;用户传入的参数个数是:&quot;,len(args)) print(&apos;args=&apos;, args)# func() # 无参调用# func(1, 2, 3)func(1, 2, 3, &quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;)#用户传入的参数个数是: 6# args= (1, 2, 3, &apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;) 练习: 写一个函数,mysum 可以传入任意个数字的实参,此函数调用将返回实参的和 123456789def mysum(*args): # s = 0 # for x in args: # s += x # return s return sum(args)print(mysum()) # 0print(mysum(1, 2, 3)) # 6 练习: 写一个函数min_max(…) 函数, 此函数至少要传一个参数,并返回全部这些数数的最小值,最大值(形成元组,最小在前,最大值在后) 调用此函数,得到最小值和最大值并打印出来 123456789101112131415161718192021222324252627282930313233343536373839# 方法1# def min_max(a, *args):# zuixiao = a# for x in args:# if x &lt; zuixiao:# zuixiao = x# # 求最大# zuida = a# for x in args:# if x &gt; zuida:# zuida = x# return (zuixiao, zuida)# 方法2 # def min_max(a, *args):# zuixiao = min(args) # 先从第二个起的参数选出最小值# if a &lt; zuixiao:# zuixiao = a # zuida = max(args)# if a &gt; zuida:# zuida = a# return (zuixiao, zuida)# 方法3def min_max(a, *args): zuixiao = min(a, *args) zuida = max(a, *args) return (zuixiao, zuida)print(min_max(10, 20, 30)) # (10,30)x, y = min_max(8, 6, 4, 3, 9, 2, 1)print(&quot;最小值是:&quot;, x) # 1print(&quot;最大值是:&quot;, y) # 9# print(min_max()) # 没有实参报错 命名关键字形参: 语法: ​ def 函数名(*, 命名关键字形参1,命名关键字形参2, …): ​ 语句块 ​ # 或 ​ def 函数名(*args, 命名关键字形参1,命名关键字形参2, …): ​ 语句块 作用: ​ 强制所有的命名关键字形参都必须用关键字传参或字典关键字传参 123456789# 此示例示意命名关键字形参的定义的方式和调用方法def f1(*, c, d): #*之后的形参为命名关键字形参 print(&quot;c=&quot;, c) print(&quot;d=&quot;, d)# f1(3, 4) # 报错f1(d=4, c=3) # 关键字正确d1 = &#123;&apos;c&apos;:30, &apos;d&apos;: 40&#125;f1(**d1) 123456789# 此示例示意命名关键字形参的定义的方式和调用方法def f2(a, b, *args, c, d): print(a, b) print(args) print(c, d)# f2(1, 2, 3, 4, d=200, c=100)f2(11,22, 33, **&#123;&apos;c&apos;:11, &apos;d&apos;:22&#125;) 双星号字典形参 语法: ​ def 函数名(**字典形参名): ​ 语句块 作用: ​ 收集多余的关键字传参 说明: ​ 字典形参名一般命名为”kwargs” 1234567891011121314151617# 此示例示意双星号字典形参的定义和调用def fun(**kwargs): print(&quot;关键字传参个数是&quot;, len(kwargs)) print(&apos;kwargs=&apos;, kwargs)fun(a=1, b=&quot;BBBB&quot;, c=[2,3,4]) # 关键字传参fun()fun(a=1, b=2, c=3, d=4)#关键字传参个数是 3# kwargs= &#123;&apos;a&apos;: 1, &apos;b&apos;: &apos;BBBB&apos;, &apos;c&apos;: [2, 3, 4]&#125;#关键字传参个数是 0# kwargs= &#123;&#125;#关键字传参个数是 4# kwargs= &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125; 函数的参数说明: 位置形参,星号元组形参,命名关键字形参,双星号字典形参,缺省参数可以混合使用 函数参数自左至右的顺序为: 位置形参 星号元组形参 命名关键字形参 双星号字典形参 示例: def fx(a, b, *args, c, d, **kwargs): ​ pass fx(1,2,3,4,5, c=’C’, d=’D’, e=’E’) # 可以接收任意的位置传参和关键字传参的函数: def fn(*args, **kwargs): ​ print(‘args=’, args) ​ print(‘kwargs=’, kwargs) fn(1, 2, “ABCD”, [11,22], 3, c=100,**{‘a’:200}) 思考题: 查看 ​ >&gt;&gt; help(print) 猜想print()函数是形参列表是如何定义的? ​ def myprint(*args, sep=’ ‘, end=’\n’): 查看&gt;&gt;&gt; range()函数猜想它的形参列表是如何定义的 练习: 写一个myrange函数,参数可以传入1~3个,实际含义与range函数相同 此函数返回符合range(…) 函数的列表 如: ​ L = myrange(4) ​ print(L) # [0, 1, 2, 3] ​ L = myrange(4, 6) ​ print(L) # [4, 5] ​ L = myrange(1, 10, 3) ​ print(L) # [1, 4, 7] (注: 可以调用range) 12345678910111213141516171819202122def myrange(a, b=None, c=None): if b is None: start = 0 stop = a # 第一个数 else: start = a stop = b if c is None: step = 1 else: step = c # print(&quot;开始值:&quot;, start, # &quot;结束值:&quot;, stop, # &apos;步长&apos;, step) return list(range(start, stop, step))L = myrange(4)print(L) # [0, 1, 2, 3]L = myrange(4, 6)print(L) # [4, 5]L = myrange(1, 10, 3)print(L) # [1, 4, 7] 全局变量和局部变量 局部变量: 定义在函数内部的变量称为局部变量(函数的形参也是局部变量) 局部变量只能在函数内部使用 局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁 全局变量: 定义在函数外部,模块文件内部的变量称为全局变量 全局变量,所有的函数都可以直接访问(但不能直接将其赋值) 1234567891011121314# 此示例示意全局变量和局部变量a = 100 # 全局变量b = 200 # 全局变量def fx(c): # c是局部变量 d = 400 # 局部变量 a = 10000 print(a, b, c, d) # 优先访问局部变量fx(300)print(&apos;a =&apos;, a) # 100print(&apos;b =&apos;, b)# print(&apos;c =&apos;, c) # 出错# print(&apos;d =&apos;, d) # 出错 说明: \1. 在函数内部的赋值语句会创建局部变量,不会对全局变量造成影响 \2. 局部变量只能在其被声明的函数内部访问,而全局变量可以在整个模块范围内访问 globals() 和 locals() 函数 globals() 返回当前全局作用域内变量的字典 locals() 返回当前局部作用域内变量的字典 123456789101112131415a = 1b = 2c = 3def fn(c, d): e = 300 # 此时有几个局部变量 print(&quot;locals() 返回:&quot;, locals()) #此时有几个全局变量 print(&quot;globals() 返回:&quot;, globals()) print(c) # 访问局部变量100 print(globals()[&apos;c&apos;]) # 访问全局变量c 3fn(100, 200) 练习: 素数/质数 ​ 2, 3, 5, 7, 11, 13 \1. 写一个函数isprime(x) 判断x是否是素数.如果是素数返回True,否则返回False 1234567891011121314def isprime(x): # 如果x小于2不是素数 if x &lt; 2: return False # 如果x大于等于2,则用x对2...x-1的数求余. for i in range(2, x): # 如果余数为0则不是素数 if x % i == 0: return False # 否则就为素数 return Trueprint(isprime(4)) # Falseprint(isprime(5)) # True \2. 写一个函数prime_m2n(m, n) 返回从m开始,到n结束的范围内的素数(不包含n),返回这些素数的列表,并打印 ​ 如: ​ L = prime_m2n(5, 10) ​ print(L) # [5, 7] 12345678910def prime_m2n(m, n): L = [] for x in range(m, n): # 判断如果x是素数,则加到列表L中 if isprime(x): L.append(x) return LL = prime_m2n(5, 10)print(L) # [5, 7] \3. 写一个函数primes(n) 返回指定范围n以内的素数(不包含n)的全部素数的列表,并打印这些素数 ​ L = primes(10) ​ print(L) # [2, 3, 5, 7] ​ 1) 打印100以内的全部素数 ​ 2) 打印200以内的全部素数的和 123456789def primes(n): return prime_m2n(0, n)L = primes(10)print(L) # [2, 3, 5, 7]# 1) 打印100以内的全部素数print(primes(100))# 2) 打印200以内的全部素数的和print(sum(primes(200))) 函数变量 函数名是变量,他在创建时绑定一个函数 1234567891011# 此示例示意函数名绑定函数,函数名是变量 def fn(): print(&quot;hello world&quot;)f1 = fnprint(f1) # &lt;function fn at 0x7f0bb2eb0f28&gt;fn() # hello worldf1() # hello worldf2 = fn() #print(f2) # None 12345678def f1(): print(&quot;hello f1&quot;)def f2(): print(&quot;hello f2&quot;)f1, f2 = f2, f1f1() # hello f2 一个函数可以作为另一个函数的实参传递 1234567891011121314151617def f1(): print(&quot;hello f1&quot;)def f2(): print(&quot;hello f2&quot;)def fx(fn): print(fn) # &lt;function f1 at 0x????&gt; fn() # 请问调用谁?fx(f1)fx(f2)#&lt;function f1 at 0x0000000002071E18&gt;#hello f1#&lt;function f2 at 0x0000000002856598&gt;#hello f2 观查下面函数的执行结果是什么? def goodbye(L): ​ for x in L: ​ print(“再见:”, x) def hello(L): ​ for x in L: ​ print(“您好:”, x) def fx(fn, L): ​ fn(L) fx(goodbye, [“Tom”, “Jerry”, “Spike”]) 看懂如下代码: def myinput(fn): ​ L = [1, 3, 5, 7, 9] ​ r = fn(L) ​ return r print(myinput(max)) # 9 print(myinput(min)) # 1 print(myinput(sum)) # 25 结果： 再见: Tom 再见: Jerry 再见: Spike 函数可以作为另一个函数的返回值 1234567891011121314# 函数可以作为另一个函数的返回值def get_function(): s = input(&quot;请输入您要做的操作:&quot;) if s == &apos;求最大&apos;: return max if s == &apos;求最小&apos;: return min if s == &apos;求和&apos;: return sumL = [2, 4, 6, 8, 10]f = get_function()print(f(L)) 函数的嵌套定义: 函数嵌套定义是指一个函数里用def语句来创建其它函数的情况 12345678910# 此示例示意函数嵌套定义def fn_outter(): print(&quot;fn_outter被调用&quot;) def fn_inner(): print(&quot;fn_inner被调用&quot;) fn_inner() # 调用一次 fn_inner() # 调用第二次 print(&quot;fn_outter调用结束!&quot;)fn_outter() python的作用域: 作用域也叫命名空间,是访问变量时查找变量名的范围空间 python的四个作用域: ​ 作用域 英文 英文简写 局部作用域(函数内) Local L 外部嵌套函数作用域 Enclosing function local E 函数定义所在模块作用域 Global G python内建模块的作用域 Builtin(Python) B 123456789101112131415# 此示例示意python的作用域v = 100def f1(): v = 200 print(&quot;f1.v=&quot;, v) def f2(): v = 300 print(&quot;f2.v=&quot;, v) f2()f1()print(&apos;全局的v=&apos;, v)#f1.v= 200#f2.v= 300#全局的v= 100 变量名的查找规则 在访问变量时,先查找本地变量,然后是包裹此函数外部的函数内部的变量,之后是全局变量,最后是内建变量. ​ 即: L –&gt; E –&gt; G –&gt; B 在默认的情况下,变量名赋值会创建或者改变本地作用域内的变量 练习: 得到下列程序运行的结果,思考为什么? L = [1, 2] def f1(): ​ L = [3, 4, 5] f1() print(L) # [1, 2] 因为f1()只制造了局部变量 def f2(): ​ L += [3, 4, 5] # L = L + [3, 4, 5] f2() print(L) # 出错 def f3(): ​ L[:] = [3, 4, 5] f3() print(L) # [3, 4, 5] global 语句 作用: ​ 告诉解释执行器,global 语句声明的一个或多个变量,这些变量的作用域为模块级作用域(也称作全局变量) ​ 全局声明(global) 将赋值语句的变量映射到模块文件内部的作用域 语法: ​ global 变量1, 变量2, …. 12345678910# 此示示意global语句的用法v = 100def f1(): global v # 全局声明 v = 200f1()print(&apos;v=&apos;, v) # ???#200 说明: ​ \1. 全局变量如果要在函数内部被赋值,则必须经过全局声明,否则会被认为是局部变量 ​ \2. 全局变量在函数内部不经过全局声明就可以访问(取值) ​ \3. 不能先声明局部变量,再用global声明为全局变量,此做法不附合规则 ​ \4. global变量列表里的变量名不能出现在函数的形参列表里 练习: 写一个函数hello,部分代码如下: ​ count = 0 ​ def hello(name): ​ print(“你好”, name) ​ … 此处略 当调用hello函数时,全局变量count自动做加1操作来记录hello被调用的次数 如: ​ hello(“Tom”) ​ hello(“Jerry”) ​ print(“hello函数共被调用%d次” % count) # 2 ​ 1234567891011121314151617count = 0def hello(name): print(&quot;你好&quot;, name) global count # 全局声明 count += 1hello(&quot;Tom&quot;)hello(&quot;Jerry&quot;)print(&quot;hello函数共被调用%d次&quot; % count) # 2hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)hello(&quot;Jerry&quot;)print(&quot;hello函数共被调用%d次&quot; % count) # 8 nonlocal语句 作用: ​ 告诉解释执行器,nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量 语法: ​ nonlocal 变量名1, 变量名2, … 123456789101112131415161718192021# 此示例示意nonlocal的用法var = 100def f1(): var = 200 print(&quot;f1.var=&quot;, var) # 200 def f2(): nonlocal var var = 300 # 想修改f1里的var为300 print(&quot;f2.var=&quot;, var) # 300 f2() print(&quot;f1.var=&quot;, var) # 300f1()print(&quot;全局的var=&quot;, var)#f1.var= 200#f2.var= 300#f1.var= 300#全局的var= 100 说明: ​ \1. nonlocal 语句只能在嵌套函数内部进行使用 ​ \2. 对nonlocal变量列表内的变量赋值将对外部嵌套函数作用域内的变量进行操作 ​ \3. 当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近的一层的变量进行操作 ​ \4. nonlocal语句变量列表里的变量名,不能出现在此函数的形参列表中 问题: def 语句的作用 lambda 表达式(又名匿名函数) 作用: ​ 创建一个匿名函数对象,同def类似,但不提供函数名 语法: ​ lambda [函数形参列表]: 表达式 123456789# def myadd(x, y):# return x + y# 可以用lambda改写如下:# myadd = lambda x, y: x + ymyadd = lambda *args : sum(args)print(&quot;20+30=&quot;, myadd(20, 30)) # 50print(&quot;100+200=&quot;, myadd(100, 200)) # 300 说明: ​ lambda 表达式创建的函数只能包含一条表达式且直接返回表达式的值 ​ lambda 比函数简单,且可以随时创建和销毁,有利于减少程序的偶合度 ​ def xxx ([函数形参列表]): ​ return 表达式 练习: \1. 写一个lambda表达式: ​ fx = lambda n: … ​ 此表达式创建的函数判断n这个数的2次方+1能否被5整除,如果能整除返回True,否则返回False ​ 如: ​ print(fx(3)) # True ​ print(fx(4)) # False 12345# fx = lambda n: (n ** 2 + 1) % 5 == 0fx = lambda n: True if (n ** 2 + 1) % 5 == 0 else Falseprint(fx(3)) # Trueprint(fx(4)) # False \2. 写一个lambda表达式来创建函数,此函数返回两个形参变量的最大值 ​ def mymax(x, y): ​ … ​ ​ mymax = lambda … ​ print(mymax(100, 200)) # 200 ​ print(mymax(“ABC”, “123”)) # ABC 12345# mymax = lambda x, y: max(x, y)mymax = lambda x, y: x if x &gt; y else yprint(mymax(100, 200)) # 200print(mymax(&quot;ABC&quot;, &quot;123&quot;)) # ABC eval() 和 exec() 函数 eval 函数 作用: ​ 把一个字符串当表达式来执行,返回表达式执行后的结果 格式: ​ eval(source, global=None, local=None) 示例: ​ s = “1 + 2 * 3” ​ v = eval(s) # v = 7 ​ print(v) # 7 ​ x = 100 ​ y = 200 ​ s = “x + y” ​ v = eval(s) # v = 300 12345678910111213# 此示例示意eval函数的参数的用法x = 100y = 200s = &quot;x + y&quot;v = eval(s)print(v) # 300# 假设局部作用域内有 x =1 ; y = 2v2 = eval(s, None, &#123;&apos;x&apos;:1, &apos;y&apos;: 2&#125;)print(v2) # 3# 设置局部作用域内有y=2,全局作用域: x=10,y=20v3 = eval(s, &#123;&apos;x&apos;:10, &apos;y&apos;:20&#125;, &#123;&apos;y&apos;:2&#125;)print(&apos;v3=&apos;, v3) # 12 exec 函数 作用: ​ 把一个字符串当程序来执行 格式: ​ exec(source, global=None, local=None) 示例: ​ s = “x=100\ny=200\nprint(‘x+y=’,x+y)” ​ exec(s) ​ s = “print(x+y)\nprint(x*y)” ​ exec(s, {‘x’:10, ‘y’:20}, {‘y’:2}) 练习: \1. 看懂下面的程序在做什么 ​ def fx(f, x, y): ​ print(f(x, y)) ​ fx((lambda a, b: a + b), 100, 200) ​ fx((lambda a, b: a**b), 3, 4) \2. 给出一个整数n,写一个函数来计算 ​ 1 + 2 + 3 + 4 + … + n 的值并返回结果 ​ 要求用函数来做 123456789101112# 方法1# def mysum(n):# s = 0# for x in range(1, n + 1):# s += x# return sdef mysum(n): return sum(range(1, n + 1))print(mysum(100)) # 5050print(mysum(10)) # 55 \3. 给出一个整数n,写一个函数来计算n!(n的阶乘)) ​ n! = 1234…*n 12345678def myfac(n): s = 1 for x in range(1, n + 1): s *= x return sprint(myfac(5)) # 120 \4. 给出一个整数n,写一个函数来计算 ​ 1+22+33+…+ n**n的和 ​ (n给一个小点的数) 12345678910111213141516# 方法 1# def f(n):# s = 0# for x in range(1, n + 1):# s += x ** x# return s# 方法2def f(n): return sum(map( lambda x:x**x, range(1, n+1) ))print(&quot;f(2) = &quot;, f(2))print(&quot;f(5) = &quot;, f(5)) \5. 写程序打印杨辉三解(只打印6层) ​ 1 ​ 1 1 ​ 1 2 1 ​ 1 3 3 1 ​ 1 4 6 4 1 ​ 1 5 10 10 5 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 第一步,制造相应的列表def get_next_list(L): # 用给定的一行L ,返回下一行 # 如L为[1, 2, 1] 则返回 [1, 3, 3, 1] rl = [1] # 最左边的1 # 算中间的数字(循环获取从0开始的索引) for i in range(len(L) - 1): v = L[i] + L[i + 1] rl.append(v) rl.append(1) # 最右边的1 return rl# 第二步,生成全部的行放到一个整体的列表rl中,并返回def yh_list(n): # n为行数 # 如果 n为3 最终返回的列表是: # [[1],[1, 1], [1, 2, 1]] rl = [] L = [1] while len(rl) &lt; n: rl.append(L) # 加入当前行 # 计算出下一行准备加入 L = get_next_list(L) return rl# 第三步,把杨辉三解的列表转为字符串列表# 如果给定的列表是[[1], [1, 1], [1, 2, 1]]# 返回 [&apos;1&apos;, &apos;1 1&apos;, &apos;1 2 1&apos;]def get_yh_string(L): rl = [] for line in L: # line = [1, 2, 1] -&gt; s = &apos;1 2 1&apos; str_lst = [str(x) for x in line] # str_lst = [&apos;1&apos;, &apos;2&apos;, &apos;1&apos;] s = &apos; &apos;.join(str_lst) rl.append(s) return rl# 打印杨辉三解def print_yh_triangle(L): # L = [&apos;1&apos;, &apos;1 1&apos;, &apos;1 2 1&apos;] max_len = len(L[-1]) for s in L: print(s.center(max_len))L = yh_list(10)SL = get_yh_string(L)print_yh_triangle(SL)]]></content>
      <categories>
        <category>python函数</category>
      </categories>
      <tags>
        <tag>python函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2019%2F01%2F05%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&lt;&lt; Python语言 编程基础 &gt;&gt;python简介诞生 ​ 创建人: Guido Van Rossum ​ 时间: 1989 python应用领域:​ 系统运维,网络编程,科学计算,人工智能,机器人,web开发 ​ 云计算,大数据及数据库编程,教育,游戏，图像等 Python的优缺点: 优点: ​ 面向对象(Java, C++, Python, C#， Swift) ​ 免费 ​ 可移植(Windows/Linux/Unix) ​ 可混合编程(C/C++/Java/.net) ​ 简单易学易用 ​ 开发效率高 ​ 应用领域广泛 ​ 开源 缺点: ​ 与C/C++相比，执行速度不够快,不能封闭源代码 python 的官网: https://www.python.org python的版本: ​ Python V2.7 (2020年结束维护) ​ Python V3.5 (当前教学版本) ​ Python V3.8 (最新) 下载地址: http://www.python.org/getit python的安装：可以安装在Linux/Unix/Windows下 python 的运行 python的解释执行器的类型: ​ CPython (C语言开发) ​ Jython (Java开发) ​ IronPython(.net开发) 第一个Python程序 Visual Studio Code使用 编写 hello.py 写入（左侧不能加空格）: ​ print(“hello world!”) 执行程序 : 在终端内: ​ $ python3 文件路径名.py python文件的后缀 .py 为python语言后缀 .c C语言文件后缀 .cpp/.cxx/.cc/.C C++语言后缀 .java Java语言后缀 在python的交互模式下编写并执行代码 进入交互模式: $ python3 &lt;回车&gt; 退出交互模式: ​ >&gt;&gt; quit() &lt;回车&gt; ​ >&gt;&gt; exit() &lt;回车&gt; ​ >&gt;&gt; &lt;输入ctrl + d&gt; python的注释:以 # 开头直至行尾 作用: ​ 让注释内容不参加解释执行 vs code 快捷键: ctrl + / python 程序的组成: 程序由模块组成 模块由语句，函数，类等组成 语句包含表达式 表达式建立并创建数据对象 python中自动化内存管理a = 1000 b = 2000 a = a + b # 释放1000这个对象,a重新绑定在3000上 c = a # c同时绑定在3000上 在交互模式下，查看当前作用域内的所有变量:>&gt;&gt; help(‘main‘)Python的核心数据类型: 数字(整数,浮点型数, 复数，布尔型数(bool)),字符串,列表等 整型数 int 整型数是不带小数部分的数字，包括自然数和负数自然数 如: -5, 100, 0等 整型数的字面值的表示方式: 十进制表示 ​ 如: ​ 10 ​ 200 ​ 9999999999999999 ​ -100 ​ 0 八进制方式表示(0o开头，后跟0~7) ​ 如: ​ 0o177 (127) ​ 0o11 (9) 十六进制方式表示(0x开头,后跟0~9,A-F,a-f) ​ 如: ​ 0x11 # (17) ​ 0xFF # (255) ​ 0x0a # 10 ​ 0x1a2b3c4d 二进制表示方式(0b开头，后跟 0~1) ​ 如: ​ 0b0000 # 0 ​ 0b0001 # 1 ​ 0b0010 # 2 ​ 0b01001000 # 72 进制转换: 十进制: 逢十进一 二进制: 逢二进一 …… 浮点型数 float 浮点数是带有小数部分的数字(小数部分可以为0) 浮点数字面值的表示方式: 小数表示: ​ 如: ​ 3.14 3.1 3. 0.14 .14 科学计数法:​ 格式: ​ 小数 e/E 正负号 指数 ​ 如: ​ 6.18E-1 # 等同于0.618 ​ 2.9979e8 # 等同于299790000.0 复数的表示方式: complex 分为两部分: ​ 实部(real) ​ 虚部(image) 如: ​ 1j ​ 1+2j ​ -2j ​ (-100+200j) 注: 虚部以 J 或 j结尾的数 布尔型数 bool (boolean)用来表示真和假两种状态的类型 ​ True 表示真(条件满足或成立) ​ False 表示假(条件不满足或不成立) 说明: ​ True 的值为1 ​ False 的值为0 空值 None None是一个表示不存在的特殊对象 作用: ​ 用来占位 ​ 变量解除绑定 表达式和运算符(也叫操作符) 算术运算符: \+ 加法 \- 减法 * 乘法 / 除法 // 地板除 % 求余 ** 幂运算 / 除法 除法得到的数是浮点数，不会丢弃小数部分 如: ​ 1 / 3 得 0.333333333333333 ​ 8 / 2 得 4.0 // 地板除 floordiv 除的结果去掉小数部分向下取整 如: 7 / 3 得 2.33333333333333 ​ 7 // 3 得 2 ​ 8 // 3 得 2 ​ 3.25 // 1.5 # 得 2.0 % 求余 7 % 3 得 1 3.25 % 1.5 得 0.25 ** 幂运算 x ** y 表示 x 的 y次方 如: ​ 4 ** 2 # 得 16 ​ 3.0 ** 4.0 # 得 81.0 ​ 5.6 ** 1.418 # 11.506165654866916 运算符的优先级:** \* / % // \+ - 示例: 1 + 3 * 3 ** 2 + 4 // 2 1 + 3 * 9 + 4 // 2 1 + 27 + 4 // 2 1 + 27 + 2 ​ 28 + 2 30 括号分组子表达式 用() 可以将表达式分组，()内部的表达式先进行计算 混合类型自动升级 1 +2.14 返回类型为浮点数 3.14 is / is not 运算符 作用: ​ 判断两个对象是否是同一个对象,当是同一对象时返回True,否则返回False 注: ​ is not 返回值与is 相反 语法: ​ x is y ​ # 或 ​ x is not y id(x) 函数: 作用: ​ 返回一个对象在内存的中的地址 如: ​ a = 10000 ​ b = 10000 ​ print(id(a)) ​ print(id(b)) ​ print(id(a is b)) # True or False? 小整数对象池 CPython中 整数 -5 至 256 的整数永远存在于小整数对象池中，不会释放并一直可用 复合赋值算术运算符:运算符 说明 y += x 等同于 y = y + x y -= x 等同于 y = y - x y *= x 等同于 y = y * x y /= x 等同于 y = y / x y //= x 等同于 y = y // x y %= x 等同于 y = y % x 比较运算符: &lt; 小于 &lt;= 小于等于 \&gt; 大于 \&gt;= 大于等于 == 等于 != 不等于 语法: ​ 左表达式 &lt; 右表达式 说明: ​ 比较运算符返回布尔类型的值 例: ​ 100 &lt; 200 # 返回True ​ 100 &gt;= 200 # 返回False 比较运算符的数据表示：0 &lt;= 30 &lt; 100 # 布尔运算:运算符: ​ not and or 布尔非操作 not 语法: ​ not x 作用: ​ 对x进行布尔取非,如bool(x) 为True,则返回False,否则返回True 示例: ​ not True # False ​ not False # True ​ not 0 # True ​ not 100 # False 布尔与操作 and 语法: ​ x and y ​ 注: x, 代表表达式 作用: ​ 优先返回假值对象,当x的布尔值为False时返回x,否则返回y 示例: ​ True and True # True ​ True and False # False ​ False and True # False ​ False and False # False 布尔或操作 or 语法: ​ x or y来绑定 作用: ​ 优先返回真值对象,如果x为True时返回x,否则返回y 示例: ​ True or True # True ​ True or False # True ​ False or True # True ​ False or False # False 正负号运算+(正号) -(负号) 一元运算符(只有一个元素参加运算) 示例: ​ a = 5 ​ b = -a # b = -5 ​ c = +a # c = 5 数据对象的构造(创建)函数float(obj) 用字符串或数字转换为浮点数，如果不给出参数，则返回0 int(x,base=10) int(x=0) 用数字或字符串转换为整数，如果不给出参数，则返回0 complex(r=0.0, i=0.0) 用数字创建一个复数(实部为r,虚部为i) bool(x) 用x创建一个布尔值(True/False) 函数调用函数名(传参列表) ​ 说明: 函数调用是表达式，一定会返回一个对象的引用关系(或者返回None) bool(x) 返回假值的情况: None 空值 False 布尔假值 0 0.0 0j 所有的数字0 &apos; &apos; 空字符串 ( ) 空元组 [ ] 空列表 { } 空字典 ... 预置(内建)的数值型函数 abs(x) 取x的绝对值 round(number[,ndigits]) 对数值进行”四舍五入”, ndigits是小数向右取整的位数,负数表示向左取整 pow(x, y, z=None) 相当于 xy 或 xy%z help() 查看函数绑助 >&gt;&gt; help(函数名) 变量 什么是变量 ​ 变量是关联一个对象的标识符 ​ 变量可以绑定一个对象，并可能通过变量名来使用这个对象 标识符的命名方法 标识符必须为字母或下划线开头，后跟字母或下划线或数字 不能使用python的关键字 变量名区分大小写 合法的变量名示例: a a1 a100 bbbbb hello _abc var A1B2 a_b_c 不合法的变量名示例: 1a 123 $abc +a #abc True python的关键字不能作为变量名: True, False, None, is, del, if, while,for .... 赋值语句语法: ​ 变量名 = 表达式 ​ # 或 ​ 变量名1 = 变量名2 = 变量名3 = 表达式 ​ # 或 ​ 变量名1, 变量名2, … = 数值1, 数值2,… 作用: ​ 创建一个变量或修改一个变量绑定的数据 说明: ​ \1. 当变量不存在时，创建该变量，同时将变量绑定在表达式返回的对象上 ​ \2. 当变量存在时，改变此变量绑定的对象 ​ \3. 一个变量只能绑定一个对象 ​ \4. 两个变量可以同时绑定在同一个对象上 示例: ​ pi = 3.1415926 ​ a = 10 ​ b = a # a和b 同时绑定在一个10上 python 中关联, 绑定，引用的含义 在python中，变量是没有类型 关联，绑定，引用都是指变量和一个对象的关联关系 示例: a = 10 + 20 a = b = c = 100 # a,b,c三个变量同时绑定在100上 a, b, c = 100, 200, 300 # 序列赋值 序列赋值的语法:变量名1, 变量名2, ... = 对象1, 对象2, ... 变量名1, 变量名2, ... = [对象1, 对象2,...] 变量名1, 变量名2, ... = (对象1, 对象2,...) 表达式 expression 由一个数字 或 数字和运算符组成 作用: ​ 让计算机做事情并返回结果(一定会返回结果) 示例: ​ 1 ​ 1 + 2 # 返回一个3(创建或生成一个3) del 语句 作用: ​ 用于删除变量,同时解除与对象的关联关系，如果可能则释放对象 语法: ​ del 变量名1, 变量名2, …. 自动化内存管理和引用计数 每个对象都会记录有几个变量绑定(引用)自身，当引用数量为0时， 则此对象被销毁，此种自动化内存管理的方式叫做引用计数 语句 statement 语句是python执行的最小单位 语句由一些表达式组成,通常一条语句可以独立执行来完成一部分事情并形成结果 ​ (一条语句建议写在一行内),多条语句写在一行内需要用分号(;) 分开 示例: print(&quot;hello&quot;) ​ x = 100 + 200 ​ # 写在一起为: ​ print(“hello”); x = 100 + 200 语句的显示换行 折行符 \ (读作:反斜杠) ​ 折行符必须放在一行的末尾,来示意解释执行器,下一行也是本行的语句 语句的隐式换行所有的括号的内容换行称为隐式换行 括号: ( ) [ ] { } 基本输入函数 input 作用: ​ 从标准输入设备上(默认为键盘)读取一个字符串 ​ (末尾的换行字符会被删除) 格式: ​ input(‘提示字符串’) 说明: ​ 返回输入的字符串(仅python3) ​ ‘提示字符串’可以省略不写 基本输出函数print 作用: ​ 将一系列的值以字符串形式输出到标准输出设备上(默认是终端) 格式: ​ print(value,…, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False) 关键字参数: ​ sep 两个值之间的分隔符,默认为一个空格’ ‘ ​ sep 输出完毕后在字符流末尾自动追加一个字符串,默认为换行符’\n’ ​ file: 文件流对象，默认为(sys.stdout) ​ flush: 是否立即进行输出 python3中常用于序列的函数:len(x) 返回序列长度 max(x) 返回序最的最大值元素 min(x) 返回序列的最小值元素 sum(x) 返回序列中所有元素的和(元素必须是数值类型) any(x) 真值测试,如果序列中其中一个值为真值则返回True all(x) 真值测试,如果列表中所有值为真值才返回True 示例: ​ L = [‘One’, 2, ‘三’] ​ print(len(L)) # 3 ​ L = [8, 3, 6, 2] ​ min(L) # 2 ​ max(L) # 8 ​ sum(L) # 19 ​ all( [True, 1, 0.01, [1,2,3], “hello”]) # True ​ all( [None, False, 1, 0.01, [1,2,3], “hello”]) # False ​ any( [None, False, 0, 0.0, [], ‘’, “hello”]) # True ​ any( [None, False, 0, 0.0, [], ‘’]) # False 阶段总结:​ 数据类型 ​ 不可变数据类型 ​ bool, int, float, complex, str, tuple, frozenset, bytes(字节串) ​ 可变数据类型 ​ list, dict, set, bytearray(字节数组) 运算符:​ + - * / // % ** ​ > &gt;= &lt; &lt;= == != ​ is / is not ​ in / not in ​ not and or ​ &amp; ^ | ​ + (正号), - (负号) ​ [ ] 索引/切片 表达式:1 1 + 2 max(1,2,3) + max(4,5,6) print(&quot;hello&quot;) 条件表达式 x if x &gt; y else y 全部的推导式: 列表,字典,集合推导式(三种) 语句: 表达式语句:print(&quot;hello&quot;) 赋值语句:a = 100,a = b = c = 200,x, y = 100, 200 del语句,if 语句,while语句,for语句,break语句,continue语句,pass语句 内建函数: \- 用于容器的函数:len(x),max(x),min(x),sum(x),any(x),all(x) \- 构造函数:int(x),bool(x),float(x),complex(x),str(x),list(x),tuple(x),dict(x),set(x),frozenset(x) ​ - 数值处理函数:abs(x),round(x),pow(x, y, z=None) \- 进制字符串:bin(x),oct(x),hex(x) \- 编码转换:chr(x),ord(x) \- 返回可迭代对象的函数:range(start, stop, step),reversed(x) \- 输入输出函数:input(),print(...., sep=&apos; &apos;, end=&apos;\n&apos;) \- 其它:id(x),type(x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【持续更新】hexo next主题优化手册]]></title>
    <url>%2F2019%2F01%2F02%2F%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E3%80%91hexo-next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[hexo常见操作hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo clean #清除部署緩存hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #开启预览访问端口（默认端口4000，可在浏览器输入localhost:4000预览）hexo d == hexo deploy #将.deploy目录部署到GitHubhexo g -d #生成加部署hexo g -s #生成加预览 next主题优化next风格选择next有四种风格,在站点配置文件搜索字段Scheme Settings可以看到， # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 我这里用的是四种：Gemini next菜单设置比如可以看到我的主页有首页、留言、分类、归档、标签等菜单，在站点配置文件下搜索menu:,可以看到 menu: home: / || home about: /about/ || user message: /message/ || comment tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat home就是首页;message就是留言…一开始只有首页和归档,其余的需要我们手动创建，在站点根目录下打开命令行,输入hexo new page &quot;about&quot;并在主题配置文件menu:字段处取消对about的注释重新部署我们就可以看到主页有关于这个菜单了，其他的类似，修改D:\hexoblog\source\about\index.md,就可以修改关于界面了about: /about/ || user中的user是指关于菜单附件的图标用的是图标库里面名为user的图标 添加萌妹子动图在根目录下打开命令行输入npm install --save hexo-helper-live2d 修改站点配置文件(注意不是主题配置文件)在末尾加入: live2d: enable: true scriptFrom: local model: ​ scale: 1​ hHeadPos: 0.5​ vHeadPos: 0.618 display:​ superSample: 2​ width: 150​ height: 300​ position: right​ hOffset: 0​ vOffset: -20 mobile:​ show: false react:​ opacityDefault: 0.5​ opacityOnHover: 0. 实现文章首页”分类于”、”阅读次数”等效果效果图如下: 在根目录下打开命令行依次输入以下命令:​ npm install hexo-wordcount –save npm uninstall hexo-generator-index –save npm install hexo-generator-index-pin-top –save 打开主题配置文件打开相关开关:​ post_wordcount: item_text: true wordcount: true min2read: true totalcount: true 打开…/themes/next/layout/_macro/post.swig文件把里面的代码用下面的代码替换:点击下载 打开…/themes/next/languages/zh-Hans.yml文件搜索post字段,添加一行comments: 评论数,注意其余的不要改 设置某篇文章置顶前面的流程走完后,只需要在写文章的时候在文章前面加入top: true或者top: 100(100只是个例子，数字越大越靠前),就能实现置顶效果了 常见错误本地预览和同时发布到远程的浏览结果不一致这是由缓存造成的,需要先hexo clean,再hexo g -d部署到远程 markdown高级语法插入连续多行的代码块按一个tab键,然后贴代码，保证每一行代码前都要额外的tab键,同时最前面空一行。比如,我前面插入的连续行代码的实现效果: 设置文字大小和颜色和居中效果hello,world! hello,world! hello,world! hello,world! hello,world!上面的效果需要在markdwon中的代码是这样的: hello,world! &lt;font color=&quot;#FF0000&quot;&gt; hello,world! &lt;/font&gt; &lt;font size=5&gt; hello,world! &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt;hello,world! &lt;/font&gt; &lt;center&gt;hello,world!&lt;/center&gt; 插入表格效果图: 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 markdown代码如下： | 左对齐标题 | 右对齐标题 | 居中对齐标题 | | :------| ------: | :------: | | 短文本 | 中等文本 | 稍微长一点的文本 | | 稍微长一点的文本 | 短文本 | 中等文本 |]]></content>
  </entry>
</search>
